[{"title":"汇编学习01","url":"/2025/07/18/汇编学习01（X86）/","content":"汇编学习01（X86）0x01 寄存器(Registers) 现代的x86处理器有8个32位通用寄存器： ​ 同时，在里面EAX也被称为累加器 ；ECX为 计数器，其被用为保存循环的索引（次数）。 对于EAX、EBX、ECX以及EDX，它们可被分段开来使用。例如，可以把EAX的最低2位字节视为16位寄存器（AX），也可将AX的最低位1位字节视为8位寄存器（AL），同时AX的高位1个字节也可看成8位寄存器（AH）。当2字节大小的数据放入DX中，原本DH、DL、EDX的数据会受到相应的影响。 0x02 内存&寻址模式 声明静态数据区域： a.可在内存中声明静态数据区域(类似全局变量)。.data指令用来声明数据，使得**.byte、.short、.long**可分别声明 1 、2和 4 个字节的数据。 b.同时我们可以打上标签，来引用所创建的数据地址。其给内存地址命名，而编译器&链接器 将其翻译成机器代码。 c.例子如下： 内存寻址： a.现代的x86处理器可寻址高达2^32位字节的内存(内存地址为32位宽)。 b.除了支持标签引用存储区域外，x86还提供了另一种计算&引用内存地址的方案：最多可将两个32位寄存器与一个32位有符号常量相加以计算存储器地址（其中一个可选择先*2、4或8）。 c.用mov做例子： 操作后缀 a.当我们加载一个32位寄存器时，编译器可推断出所用内存为4个字节宽，但有时候大小并不明确。 b.这时得用到前缀 b、w和 l 来分别表示1、2和4个字节的大小。 指令：分为 数据移动指令 、逻辑运算指令 、流程控制指令 。 使用： (同时所有标签&数字常量以**$**为前缀，需要时前缀 0x 表示十六进制数) a.数据移动–mov(移动)：当寄存器到寄存器之间的数据移动可行时, 直接从内存单元中将数据移动到另一内存单元中是不行的. 在这种需要在内存单元中传递数据的情况下, 它数据来源的那个内存单元必须首先把那个内存单元中的数据加载到一个寄存器中, 之后才可通过这个寄存器来把数据移动到目标内存单元中。 b.数据移动–push(入栈)：将其参数移动到硬件支持的栈内存顶端. 特别地, 其先将 ESP 中的值减少 4, 然后移动到一个 32 位地址单元 ( %esp ). ESP ( 栈指针 ) 会随着不断入栈持续递减, 即栈内存是从高地址单元到低地址单元增长。 c.数据移动–pop(出栈)：从硬件支持的栈内存顶端移除4字节数据, 并把其放到该指令指定的参数中 ( 寄存器&#x2F;内存单元 ). 其首先将内存中 ( %esp ) 的 4 字节数据放到指定寄存器或者内存单元中, 然后让 ESP + 4。 d.数据移动–lea(加载有效地址)：将其第一个参数指定的内存单元放入到 第二个参数指定的寄存器中。注意, 该指令不加载内存单元中的内容, 只是计算有效地址并将其放入寄存器。 与 mov 的区别? mov是传送数据(如MOV AX,[1000H]是将1000H作为偏移地址寻址到内存单元，将数据–>AX ) ;而lea是取偏移地址(如LEA AX,[1000H]是将[1000H]的偏移地址–>AX，等同于MOV AX,1000H)。 e.逻辑运算–add(整数相加)：将两参数相加, 然后将结果存放到第二个参数中. 注意, 参数可以是寄存器,但参数中最多只有一个内存单元。 逻辑运算–sub(整数相减)：将第二个参数的值与第一个相减, 就是后面那个减去前面那个, 然后把结果存储到第二个参数。 f.逻辑运算–inc、dec(自增，自减)：分别让参数+1、-1。 g.逻辑运算–imul(整数相乘)：有两种基本格式 : 第一种是2 个参数的 ( 先将两参数相乘, 然后把结果存到第二个参数中. 运算结果必须是一个寄存器 ); 第二种格式是3 个参数的 ( 先将其第 1 个参数和第 2 个参数相乘, 然后把结果存到第 3 个参数中,其必须是一个寄存器。此外, 第 1 个参数必须是一个常数 ). ​ 逻辑运算–idiv(整数相除)：只有一个操作数，此操作数为除数，而被除数则为EDX: EAX 中的内容（一个64位整数）， 除法结果 ( 商 ) 存在于EAX 中, 而所得的余数存在 EDX 中 h.逻辑运算–and, or, xor(按位逻辑 与，或，非)：分别对它们的参数进行相应的逻辑运算, 运算结果存到第一个参数中。 i.逻辑运算–not(逻辑位运算 非)：对参数进行逻辑非运算, 即翻转参数中所有位的值。 j.逻辑运算–shl, shr(按位左移&#x2F;右移)：对第一个参数进行位运算, 移动的位数由第二个参数决定, 移动过后的空位拿 0 补上.被移的参数最多可以被移 31 位. 第二个参数可以是 8 位常数或者寄存器 CL. 在任意情况下, 大于 31 的移位都默认是与 32 取模。 [!IMPORTANT] x86处理器有**指令指针寄存器(EIP)，为32位寄存器，用来在内存中指示输入汇编指令的位置，指向哪个内存单元。 我们用<label来当作标签，输入标签+冒号，可将其插入x86汇编代码任意位置。 k.流程控制–jmp(跳转指令)：将程序跳转到参数指定的内存地址, 然后执行该内存地址的指令。 l.流程控制–jcondition(有条件跳转)：是条件跳转指令，基于一组条件代码的状态，这些状态存放在叫机器状态字的寄存器中，其内容包括关于最后执行的算术运算的信息。 m.流程控制–cmp(比较指令)：比较两个参数的值, 适当地设置机器状态字中的条件代码. 此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中。 n.流程控制–call、ret(子程序调用&返回)：实现子程序的调用和返回。call指令首先把当前代码位置推到内存中硬件支持的栈内存上，然后无条件跳转到标签参数指定的代码位置，在其结束后，返回调用之前的位置；ret指令则实现子程序的返回，其首先从栈中取出代码(类似于pop),然后无条件跳转到检索到的代码位置。 调用约定(关于如何从例程调用&返回的协议)：分为两组:第一组是面向子例程的调用者的；第二组则是面向子例程的编写者，即被调用者。 a.调用者约定：要调用子例程，请使用call指令(将返回地址存到栈上，并跳转到子程序的代码，其中子程序应遵循被调用者约定) b.被调用者约定：应先将EBP的值入栈，再将ESP的值复制到EBP中(保留基指针EBP以作为栈上找到参数&变量的参考点) 子程序序言执行标准操作，即在EBP中保存栈指针的副本，通过递减栈指针来分配局部变量，并在栈上保存寄存器的值。 函数的结尾则基本上是函数序言的镜像，从栈上恢复调用者的寄存器值，通过重置栈指针来释放局部变量，恢复调用者的EBP值，并使用ret指令返回调用者中相应代码位置。","date":"2025-07-18","categories":["CTF相关"],"tags":["CTF基础知识"]},{"title":"渗透测试01","url":"/2025/06/13/渗透测试01/","content":"渗透测试010x0.介绍 渗透测试就是一种通过模拟恶意攻击者的技术&方法，挫败目标系统安全控制措施、取得访问控制权、同时发现具备业务影响后果安全隐患的安全测试与评估方式。 其一般需要对系统进行目标系统进行主动探测分析，以发现潜在的系统漏洞（包括不恰当的系统配置、已知或未知的软件硬件漏洞，以及在安全计划与响应过程中的操作性弱点…） 0x1.分类 黑盒测试（外部测试），设计为模拟一个对客户组织一无所知的攻击者所进行的渗透测试。 a.采用该方式时，渗透测试人员将从一个远程网络位置来评估目标网络基础设施。值得注意的是，他们并没有任何目标网络内部拓扑等相关信息，即完全模拟外部攻击者，采用流行的攻击技术&工具对目标组织进行逐步的渗透与入侵，揭示目标网络中的已知&#x2F;未知安全漏洞，并评估这些漏洞是否能被利用来获取控制权&#x2F;造成相关业务资产的损失。 b.黑盒测试比较费时费力，同时也需要具备较高的技术能力。因此，也更受推崇。 白盒测试（内部测试），设计为人员在拥有客户组织所有知识的情况下所进行的渗透测试。 a.采用该方法时，渗透测试人员可以了解到关于目标环境的所以内部&底层知识 &#x3D;> 以最小代价发现&验证系统中最严重的安全漏洞。 b.白盒测试无需进行目标定位与情报搜集（在CTF中，一般是进行黑盒测试）；同时，其能够更加方便地在一次常规开发&部署计划周期中集成，避免被入侵者发现利用可能存在的安全漏洞。 c.其无法有效测试客户组织的应急响应程序。 灰盒测试（白+黑的组合） a.灰盒测试需要渗透测试人员能够根据对目标系统所掌握的有限知识与信息，来评估整体安全性的最佳途径。 b.简单来说，结合了黑盒测试&白盒测试的各自优点。 0x2.渗透测试阶段 前期交互：确定渗透测试的范围、目标、限制条件以及业务目标… 情报搜集（白盒测试无）：获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息 a.可以使用的方法包括公开来源信息查询、Google Hacking、社会工程学（社工，哈哈）、网络踩点、扫描探测（类似于嗅探）、被动监听、服务查点… 威胁建模：通过共同的缜密情报分析&攻击思路brainstorm，可以确定最可行的攻击通道。 漏洞分析（如何root&#x2F;提权）：综合分析+找出攻击点+验证 渗透攻击（真正提权）：考虑系统特性+挫败防御措施（+考虑检测机制的逃逸–黑盒） 后渗透攻击：根据目标组织不同特点，自主设计攻击目标+寻找最具价值的信息&资产，达成攻击途径。 0x3.安全漏洞生命周期 利用安全漏洞来造成入侵&#x2F;破坏效果的程序为渗透代码（EXP–CTF中的老朋友了啊）。 安全漏洞研究&挖掘：主要利用源代码审计（白盒测试）+逆向工程（灰盒测试）+Fuzz测试（黑盒测试）等方法，挖掘可用漏洞。 渗透代码开发与测试：黑客们会开发概念验证性的渗透代码 &#x3D;> POC，用于验证漏洞是否存在。 安全漏洞&渗透代码在团队内流传：“白帽”会通知厂商修补，后者给出补丁后再发布；“黑帽”以及“灰帽”则会各自进行秘密共享，以充分利用其所带来的攻击价值。 安全漏洞&渗透代码开始扩散：安全漏洞和渗透代码最终被披露出来，在互联网上得以发布。 恶意程序出现+传播：“黑帽”在掌握安全漏洞&渗透代码的基础上，进一步开发更易使用、更具有自动化传播能力的恶意程序，并通过社区、组织、互联网传播，进而快速扩散。 渗透代码&#x2F;恶意程序大规模扩散，造成危害：厂商发布补丁和安全警报让更多黑客了解，从而加以利用。 渗透代码&#x2F;攻击工具&#x2F;恶意程序&#x3D;>消亡：检测&移除机制得到广泛使用。 [!IMPORTANT] 1.Patch为补丁； 2.从安全漏洞被发现到厂商发布Patch用于修补该漏洞之前的这段期间，称为0day； 3.在这段时间里，黑客攻击存有“0day”漏洞的目标可达到100%成功率，同时也可以躲避检测，因此“0day”和对应的渗透代码对与黑客社区有很高价值。 0x4.安全漏洞资源库国内： CNNVD:中国国家漏洞库 CNVD:中国国家信息安全漏洞共享平台 国外： CVE（通用漏洞与披露）：已成为安全漏洞命名索引的业界事实标准 NVD：国家漏洞数据库，是美国政府官方根据NIST的SCAP标准协议所描述的安全漏洞管理信息库 SecurityFocus：起源于Bugtraq邮件列表。 OSVDB：开源漏洞数据库，一个独立、开源的安全漏洞信息库","date":"2025-06-13","categories":["安全相关"],"tags":["渗透测试"]},{"title":"SRC挖洞01--信息收集_1","url":"/2025/06/11/SRC挖洞01--信息收集_1/","content":"SRC挖洞01–信息收集_10x0.目的 为什么要进行信息收集呢？这就好比我们出去旅游得做攻略了解当地习俗（吃喝玩乐），亦或是出去露营要了解环境怎么样、当天的天气咋样… 同样，SRC挖洞类似，你必须知道要面对什么，才能做好充足的准备。 0x1.获取途径 Whois信息：关于域名的基本信息。其显示了网站的注册详细信息（包括注册域名的用户&该域名的到期时间等）。在社交工程学中很有用。 IP地址：其由域名服务器解析，可以帮助我们定位网络，同时在测试时查找系统上的开放端口&其他可利用资源及服务等等。 Web服务器：是运行在OS上的应用程序，如Apache、Tomcat、IIS等等都是。当任何Web请求被发送到系统时，这些Web服务器会处理并发出响应。知道了Web服务器类型，也就能找到该服务器的默认目录及漏洞。 登录页面：这也是常出现漏洞的地方（SQL注入、弱口令…）。想进入admin页面或是获得敏感数据，就得有钥匙，可以是万能的（比如admin|admin@123、admin|123456…），或者直接爆破也行… 子域名：我们需要收集到域名下的所有可用的子域名，这样可能会发现隐藏或是私有域。而这些有在被维护的就很容易收到攻击（洪泛攻击…） 同一服务器上的其他域：很多时候没办法在目标站找到漏洞时，可以尝试通过查找反向IP域并查找同一服务器上的其他网站来locate漏洞。 Web应用程序防火墙：除了上述所讲，我们还可以测试是否使用防火墙。这样，我们可以知道要面对的&有无可以绕过该防火墙的方法。 0x2.两维度 网站框架： a. CMS、接口信息、数据库信息、编程语言、前端载体 b. OS、IP信息、CDN信息、端口协议、DNS信息、域名信息 企业相关框架： a. IP C段信息、历史备案信息、鹰图hunter&#x2F;FOFA信息 b. SRC公告中信息（测试范围…）、域名信息、企查查&#x2F;天眼查&#x2F;小蓝本信息 0x3.信息打点方向 目标公司相关： a.看目标直接开放的资产业务… b.相关单位（迂回战术）：企业总部的安全防护做得比较严格，难以正面攻破。这时，可以选择其下属单位来试试；还有就是，一个集团内部的各个分公司之间的内网隔离不彻底，可以由一个内网进入同一集团下另一分公司的内网中进行信息收集。 供应商（供应链攻击）：集中在上下游供应商，找到漏洞，攻击企业内部 a.商业购买系统 b.软件开发商 c.外包相关业务 d.代理商 e.招标&投标文件 0x4.常见打点思路 远程Web打点 a.互联网边界资产：部分开放于互联网的设备或系统（邮件、官网…） b.通用产品组件漏洞：自身安全漏洞（OA漏洞、中间件漏洞、数据库漏洞…） c. 0Day漏洞：0day漏洞能够穿透现有基于规则的防护技术。这些漏洞大部分和暴露在互联网上的Web应用相关，直接威胁到core的安全。 d. 弱口令：包括但不限于弱强度密码、默认密码、通用密码…但是现在好像基本上没见到啥弱口令了 近源攻击 a.线下门店WiFi：常见的连接方式有万能钥匙、密码爆破…像星巴克等等门店都可以进行。 b.WiFi伪造：干扰正常的WIFI运行，伪造同名的WiFi来等待目标现场的工作人员连接，再分析抓到的数据包，看看是否存在相关的关键业务地址、密码等等。 c. BadUSB：制作干扰U盘找间隙插入工作人员的电脑上，通过模拟键盘按下来执行系统命令等等。 社交工程学钓鱼攻击 a.电子邮件钓鱼 b.通讯软件钓鱼（QQ、微信等） c.最常见的网页钓鱼 d.电话社工（比较常见） e.水坑攻击 未完待续…","date":"2025-06-11","categories":["安全相关"],"tags":["SRC挖洞"]},{"title":"CTF--文件上传漏洞PLUS","url":"/2025/06/07/CTF--文件上传漏洞PLUS/","content":"CTF文件上传漏洞例题总结题目是NSSCTF上的“[SWPUCTF 2021 新生赛]easyupload1.0” 解题思路：1.打开题目靶机环境： 2.老套路，上传一句话木马，但是提示上传失败： 3.看看提示，upload1.jpg,于是将原有的🐎后缀名改为.jpg，提示上传成功并给出文件路径： 4.随后，用bp抓包，放入Repeater,并将文件名修改为.phtml： 5.最后，根据文件路径访问&#x2F;upload&#x2F;test.phtml，Ctrl+F搜索flag即可(这里则是NSSCTF)： 总结：这次试了才发现有点耗时…之前一直没敢做这种，感觉太复杂了~~ 不过，这是个好的开始！","date":"2025-06-07","categories":["CTF相关"],"tags":["CTF基础知识","CTF赛题"]},{"title":"SRC挖洞00","url":"/2025/06/03/SRC挖洞00/","content":"之前因为某些原因，想到了Social engineering，想要小小的社工一下… 在参加CTF比赛时，也在MISC里面接触到了社工题&一些“信息收集”、“POC打点”等等术语。 随后就心血来潮搜索一番，发现玩这玩意儿还有奖励、bonus!!! 于是，正式入坑SRC挖洞了 :)","date":"2025-06-03","categories":["安全相关"],"tags":["SRC挖洞"]},{"title":"C++学习02","url":"/2025/06/02/C++学习02/","content":"继承 继承让我们能依据另一个类来定义一个类，这种特性也很容易创建和维护一个程序，从而达到了重用代码功能和提高执行效率的一个效果。 ​ 当创建一个类时，无需重新编写新的数据成员、成员函数，只需指定该类继承一个已有类的成员即可， ​ 上述已有类称为基类，新建类则为派生类。 语法： a.基本：class子类(派生类) : 继承方式 父类(基类) b.共有继承：基类的公用成员和保护成员在派生类中保持原有访问属性，其私有成员仍为私有。 c.私有继承：基类的公用成员和保护成员在派生类中变为私有属性，其私有成员仍为私有。 d.保护继承：基类的公用成员和保护成员在派生类中变为保护属性，其私有成员仍为私有。 多继承：一个子类可有多个父类，继承多个父类的特性。 语法： [!NOTE] 访问修饰符继承方式可以是public、protected或private中的任何一个。 其他注意： a.派生类是不能继承基类的析构函数，也需要通过派生类的析构函数调用基类的析构函数。 b.继承中先调用父类构造函数，再调用子类的，析构函数的调用顺序与之相反。 c.C++中构造函数不能被派生类继承！ 多态 多态指具有不同功能的函数可以用同一个函数名。 这也意味在调用成员函数时会根据调用函数的对象的不同类型来执行不同函数。 当类之间存在层次结构&&类之间通过继承关联时，会用到多态。 静态多态：函数重载、运算符重载 a.重载声明指一个与之前已在该作用域内声明过的函数&#x2F;方法具有相同名称的声明，但参数列表和定义不同。 b.函数重载：同名函数功能类似，但形式参数必须不同。 c.运算符重载：运算符为带有特殊名称的函数，函数名由关键字operator和运算符符号构成。同时，重载运算符也有一个返回类型与一个参数列表。 运算符列表： 动态多态：派生类和虚函数实现运行时多态 a.虚函数 是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中的定义的虚函数时，会告诉编译器不要静态链接到基类中的该函数。 文件与流 **基本输入输出(I&#x2F;O)发生在流(字节序列)**中。 文件操作：从文件读取流和向文件写入流。 a.打开文件： 打开模式： b.关闭文件： c.读取&写入示例代码： 后记这个时间点的C++学习…懂得都懂 :)","date":"2025-06-02","categories":["程序设计"],"tags":["编程学习"]},{"title":"Db8Gr的blog01","url":"/2025/06/01/Db8Gr的blog01/","content":"重启后的第一篇文章…现在是2025-06-01的凌晨一点，(￣▽￣)”确实，是时候重新审视自己了，唉…","date":"2025-06-01","categories":["杂谈"],"tags":["随笔"]},{"title":"C++学习01","url":"/2025/05/23/C++学习01/","content":"程序的内存模型1.内存四区 ​ 代码区、全局区、栈区、堆区（代码区和全局区在程序执行前就有） 2.简单介绍 ​ 2.1 代码区： ​ 存放CPU执行的机器指令 ​ 代码区是共享的，也是只读的。 ​ 2.2 全局区： ​ 存放了全局变量（在main函数之外）、静态变量（前面有static) ​ 其中还包含了常量区。（包括字符串常量、const修饰的全局常量） ​ 该区的数据在程序结束后由操作系统释放。 ​ 2.3 栈区： ​ 由编译器自动分配释放（函数执行完） ​ 存放函数的参数值（形参）、局部变量等（不要返回局部变量的地址！！） ​ 2.4 堆区： ​ 由程序员分配释放，若不释放，则被系统回收 ​ 主要用new关键字在该区开辟数据，用delete关键字释放内存。 ​ new返回的是数据类型的指针。 ​ 释放数组时（eg. delete[] arr;） 构造函数&析构函数 构造函数用于初始化对象，同时为对象的成员属性赋值；析构函数用于清理对象，同时在对象销毁前调用执行清理工作。 语法 2.1 构造函数：类名(){} ​ 2.1.1.构造函数，没有返回值也不写void ​ 2.1.2.构造函数可以有参数，可以发生重载 2.2 析构函数：~类名(){} ​ 2.2.1.析构函数，没有返回值也不写void ​ 2.2.2.析构函数不可以有参数，不可以发生重载 3.构造函数的分类&调用 ​ 3.1 分类一（按照参数） ​ 3.1.1.无参构造（默认构造） ​ 3.1.2.有参构造 ​ 3.2 分类二（按照类型） ​ 3.2.1.普通构造 ​ 3.2.2.拷贝构造： ​ 3.3 调用 ​ 3.3.1.括号法： ​ 3.3.2.显示法： ​ 3.3.3.隐式转换法： ​ 3.4 深拷贝&浅拷贝 ​ 3.4.1.浅拷贝：简单的赋值拷贝操作（存在的问题：使堆区的内存重复释放） ​ 3.4.2.深拷贝：在堆区重新申请空间，从而进行拷贝操作 ​ 3.4.3.示例： const修饰成员函数常函数： ​ 1.成员函数后加const，称之为常函数 ​ 2.常函数内不可以修改成员属性 ​ 3.成员属性声明时加关键字mutable，在常函数中依然可以修改 常对象： ​ 1.声明对象前加const，称为常对象 ​ 2.常对象只能调用常函数 未完待续…","date":"2025-05-23","categories":["程序设计"],"tags":["编程学习"]},{"title":"CTF--Web的请求头伪造（简单的Wp）","url":"/2025/05/16/CTF--Web的请求头伪造（简单的Wp）/","content":"题目描述WEB入门5-请求头伪造 在发生HTTP请求时，往往会带上许多请求头，这些请求头是可以被我们所控制的，倘若服务端没有进行校验而轻易相信，便会出现安全问题，试试解决这个问题吧！ 解决1.将cookie中的guest权限改为admin，同时增加题述中的发出请求的用户的电子邮件地址（From:…） 2.接着增加其他题述中的请求头：X-forwards-for(从内网访问：127.0.0.1）、Via（通知中间网关或代理服务器地址，通讯协议）。 3.得到flag 请求头相关链接[CTF——HTTP发送头Headers整理](CTF——HTTP发送头Headers整理_ctf easyheader-CSDN博客)。","date":"2025-05-16","categories":["CTF相关"],"tags":["CTF基础知识"]},{"title":"CTF-文件上传漏洞","url":"/2025/05/13/CTF-文件上传漏洞/","content":"文件上传漏洞之前做了CTF的一道题，考察了文件上传，在此复习下文件上传。 文件上传漏洞原因：1.服务器配置不当2.文件上传限制被绕过3.开源编辑器的上传漏洞4.文件解析漏洞导致文件执行5.过滤不严或被绕过 可能存在漏洞的位置：1.图片上传功能 2.头像上传功能 3.文档上传功能 文件上传检测方式：1.客户端JS检测（文件扩展名）2.服务端MIME类型检测（content-type内容）3.服务端目录路径检测（跟path参数相关）4.服务器文件扩展名检测（跟文件extension相关）5.服务端文件内容检测（内容是否合法、是否含有恶意代码） 绕过客户端检测：1.原理：在上传页面里含有专门检测文件上传的JS代码，最常见的则是检测文件类型和扩展名是否合法2.方法：在本地浏览器客户端禁用JS即可3.测试：靶场 绕过服务端检测：1.服务端代码检测三点：MIME类型、文件后缀、文件内容2.常见MIME类型​ 1.HTML、txt、pdf​ 2.Word、png、gif​ 3.MPEG、AVI3.绕过MIME类型检测​ 1.原理：检测图片类型文件上传过程中http包的Content-Type字段的值，从而判断文件是否合法​ 2.方法：用BP截取并修改数据包中文件的Content-type类型来进行绕过 绕过文件后缀检测–黑名单1.后缀大小写绕过（.Php)2.空格绕过（.php ）3.点绕过（.php.）4.::DATA绕过(利用Windows下NTFS文件系统的特性,可在文件后缀名加::DATA绕过5.配合Apache解析漏洞（Apache解析有一个特点：解析从右向左，若为不可识别的则继续从左解析，Apache不解析.rar和.owf。）6..htaccess文件 1.配合名单列表绕过，上传一个自定义的.htaccess，就可绕过各种检测 2…htaccess文件（分布式配置文件）提供了针对目录改变配置的方法。 绕过文件后缀检测–白名单1.绕过方法：服务端判断文件类型是从后往前判断，而解析则是与判断相反，可用00截断的方式绕过，%00与0x00截断2.系统在对文文件名读取时，若遇到0x00,则认为读取结束。 绕过文件内容检测1.通过检测文件幻数来判断：通常，通过判断文件前10个字节，即可判断文件的真实类型。 1.绕过jpg类型的文件幻数检测要在文件开头写Value&#x3D;FF D8 FF E0 00 10 4A 49 46 2.绕过gif类型的文件幻数检测则要加Value&#x3D;47 49 46 38 39 61 3.绕过png的，则要加Value&#x3D;89 50 4E 472.通过检测文件加载：一般是调用API或函数进行文件加载测试，常见的则是图像渲染测试，那我们对渲染&#x2F;加载 测试的攻击方式时代码注入绕过，对二次渲染的则是攻击文件加载器自身。 总结：我们可以用溢出攻击对文件加载器进行攻击，上传自己的恶意代码后，服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode。","date":"2025-05-13","categories":["CTF相关"],"tags":["CTF基础知识"]},{"title":"程序员关于学习的10件事[摘自...貌似忘了:(,emmm... ]","url":"/2025/04/26/（转载）程序员关于学习的10件事/","content":"（转载）程序员关于学习的10件事0.前言终身学习，对每个人都可能是必要，对于软件工程师尤其如此。在IT领域，变化是永恒的，新技术不断被发明，旧技术不断更新。因此，软件工程师不会只学习一次编程，还可能要学习许多新的编程语言和框架。 但是，我们学习并不意味着我们理解了如何学习，人们不能凭直觉理解记忆和学习是如何工作的。认知心理学和关于编程的教育为我们如何学习提供了强有力的见解。本文阐述了关于学习的10件事，这些发现适用于软件工程师，并有着实际的意义。 1. 人的记忆不是由比特组成的记忆是学习的核心，学习意味着一个人的长期记忆发生了变化。软件开发人员都熟悉计算机内存的惊人力量，在那里可以存储一系列的比特，然后通过CPU的控制调整为正确的比特序列。尽管人的记忆有其相似性，但它既不准确，也不可靠。 由于人类记忆的生物学复杂性，可靠性是一个复杂的问题。对于计算机内存，我们使用两种基本操作: 读和写。读取计算机内存不会修改它，也不管写入和读取之间经过多少时间。人的记忆似乎有一个“读取和更新”的操作，在这个操作中，获取一段记忆可以加强和修改它。这种修改更有可能发生在最近形成的记忆上。由于这种修改的可能性，事实不存在于确定已知或未知的二元状态; 它可以存在中间状态。我们可以忘记以前知道的事情，知识可能是不可靠的。 人类记忆的另一个奇特特征是“扩散激活”。我们的记忆储存在相互连接的神经通路中，当试图记住一些东西时，我们会激活一条神经元通路来获取目标信息。然而，激活并不只包含在一个途径中。有些激活会扩散到其他相连的通道，这种扩散的激活使得相关的通路被激活数小时。传播激活对记忆有负面影响，对解决问题有正面影响。传播激活意味着相关但不精确的信息可能与目标信息混为一谈，这意味着对信息的回忆可能是不可靠的。然而，传播激活也与基于洞察力的问题解决或“顿悟时刻”有关，有时候离开一个问题去解决另一个问题，这个问题本身就在扩散，导致两个不相关的区域在中间连接起来。当两个先前不相关的领域连接起来时，就会产生创造性和独特的问题解决方案。这或许就是为什么散步，淋浴，或者其他远离问题的时间里可以帮助我们摆脱困境问题原因。 总而言之，人的记忆不是简单地从特定位置存储和检索就可以工作的，它更加脆弱和不可靠，但是，它也可以通过将知识联系在一起来，为解决问题和深入理解带来好处。 2. 人的记忆是由一个有限的和一个无限的系统组成人类记忆与学习相关的部分有两个主要的组成: 长时记忆和工作记忆。长时记忆是信息永久存储的地方，其功能是无限的，在这个意义上，它有点像计算机的磁盘存储器。然而，工作记忆用于有意识地推理信息以解决问题，它类似于 CPU 的寄存器，实时存储有限数量的信息以允许访问和操作。 工作记忆是有限的，它的容量在人们出生时大致是固定的。虽然较高的工作记忆容量与较高的智力有关，但工作记忆容量并不是最重要的因素。较高的容量使得学习更快，但是无限的长期记忆消除了我们最终能够学习多少的限制。程序员可能有较低或较高的工作记忆容量，但是，长期记忆的内容使他们成为专家。 随着人们对一个主题了解的内容越来越多，他们把信息联系在一起，形成一个个信息块，允许多个信息块作为工作记忆中的一个信息块。例如，当面对一个电子邮件地址时，一个熟悉的 gmail.com被视为一条信息，而不是随机字符串。因此，信息块越多，工作记忆就越大。与计算机类比，我们的工作记忆类比为CPU 寄存器，可能只允许在长期记忆&#x2F;磁盘中存储5个指向信息块的指针，但是对于信息块的大小没有限制，所以最佳策略是通过练习使用信息和解决问题来增加信息块的大小，这或许就是建立自己知识体系的意义。 当学习新的工具或技能时，了解任务所要求的认知负荷或工作记忆容量很重要。认知负荷分为内部负荷和外部负荷。内部负载是指完成任务所必需的信息或块的数量; 除非通过更改任务，否则不能更改内部负载。相比之下，无关的认知负荷是不必要的信息，然而，是执行任务的一部分。表达是外部认知负荷如何变化的一个例子，如果正在实现一个数据库模式，那么使用带有表和属性的图比使用简单的英语描述更容易，后者具有更高的外部负载，因为我们需要在心理上将描述转换为模式，而图可以直接映射，对于初学者来说，外部负载通常较高，因为他们不能很容易地区分内部信息和外部信息。 当面对一项超出个人能力范围的任务时，重要的是要认识到这可以通过重新组织任务来改变。将问题分解成可以处理的小块，最终将允许人员解决复杂的问题。这个原则可以应用到自己的实践中，但是当与初级开发人员和新人一起工作时，这个原则尤其重要。 3. 专家认知与初学者推理初学者和专家之间的一个关键区别是，专家以前见过类似的情况。对象棋高手而言，他们的主要优势是记忆和识别棋盘状态的能力。这使得他们能够决定如何更快更省力地做出反应。有人将认知分为“系统1”和“系统2”，系统1速度快，由识别驱动，依赖于长期记忆中的模式识别，而系统2速度慢，专注于推理，需要更多的工作记忆处理。这是双过程理论的一部分。 软件工程师可以通过记住程序代码中的常见模式来进行更高层次的推理，这释放了他们的认知能力。这种情况的一个实例是编程中的“设计模式”，类似于之前讨论的信息块。一个专家可能会立即意识到某段代码正在执行一个排序算法，而初学者可能会逐行阅读，试图理解代码的工作原理，而不会注意到整体情况。 这种情况的一个必然结果是，初学者可以通过阅读和理解大量代码而成为专家。专家们建立了一个模式的心智模型，让他们在将来更容易地读写代码，因此，学习各种编程范例将有进一步的帮助。总的来说，阅读并使用更多代码以及理解更多类型的代码是能够提高编程水平的原因。 4.理解概念从抽象到具体再到回归高手处理概念的方式与初学者不同，他们使用通用和抽象的术语来寻找基础概念，而不是关注细节，而初学者往往关注表面的细节，很难将这些细节与更大的背景联系起来。这些差异不仅影响专家的推理方式，也影响他们的学习方式。 例如，当向一个新手解释 Python 中可变参数的函数时，高手可能会说，这是一个可以接受不同数量参数的函数。初学者可能会关注一些细节，比如声明和调用函数的确切语法，并可能认为只传递一个参数是一种特殊情况。高手可能更容易理解或预测的细节，通过概念来解释。 当学习一个新概念时，可以从两种形式的解释中受益: 抽象的特征和具体的例子细节。具体而言，我们将受益于所遵循的语义。遵循语义，我们可以不断地在抽象定义和概念的几个不同示例之间切换。例子越多样化越好。与正确的例子相比，错误的例子也能帮助我们理解错误的原因，比如在试图了解常数是什么的时候，可以观测到一个变量被标记为非常数，这一过程称为拆包。 通过这些不同的示例，我们可以(重新)访问抽象定义，并构建对概念的更深入理解。更深入的理解源于认识到多个例子中的细节是如何连接到定义中的一个抽象概念的，这个过程称为重新包装。解决问题被(错误地)认为是一种通用的技能。然而，这并不是解决问题在大脑中的工作方式。 编程经常涉及到学习抽象概念。面对一个需要学习的抽象概念，比如函数，人们经常需要具体的概念实例来检查，比如，返回一个数字的绝对值函数——abs 。一个挑战是，随着概念变得更加抽象(从值到变量&#x2F;对象到函数&#x2F;类到高阶函数&#x2F;元类，最终到范畴理论) ，距离具体的例子越来越远。可取的是，当学习抽象概念时，它们对我们来说变得更加具体。最初，函数是一个抽象的概念，但是经过大量的实践，函数对我们来说变成了一个具体的代码块 ，进而可以学习下一个抽象层次。 5. 间距和重复问题都听说过不应该临时抱佛脚来应付考试，这个建议是基于认知心理学中最可预测和持久的效应之一: 间隔效应。根据间隔效应，人们通过在多个练习阶段、多天、最理想的是多周间隔练习来学习解决问题的概念。 间隔效应的机理是基于长期和工作记忆之间的关系。当练习解决问题的时候，一般练习两种技能，将问题中的信息与可以解决问题的概念匹配，然后应用该概念来解决问题。第一个技能需要激活通往长期记忆概念的正确神经通路。如果学习者反复解决同一类问题，比如 for-each 循环，那么通往长期记忆的通路就会保持活跃，他们就会错过练习第一个技能的机会。无间隔练习的一个常见结果是，人们可以解决问题，但需要被告知使用哪个概念时才能解决。虽然交织不同类型的问题可能有所帮助，如循环和条件判断，使用间隔学习有必要获得最多的练习时间。此外，大脑需要休息，以巩固新的信息，以便它可以应用于新的问题。 密集的编码训练营要求学习者将解决问题的练习塞进没有间隔的会话中，虽然这并不理想，但大多数学习者仍然喜欢把他们的练习塞进尽可能少的时间里。如果强化训练营是学习编程的唯一可行选择，可以应用间隔效应来最大化学习成果。 为了安排一天的学习时间，应该把学习时间限制在90分钟或更少。大脑中的神经化学平衡使得在这一点之后注意力难以集中。每次学习后，至少花20分钟休息。真正的休息是散步或安静地坐着，不做其他任务，无所事事地浏览互联网，或与他人聊天。休息加速了巩固过程，这也发生在睡眠期间。 有几种策略可以使学习效率最大化。首先，把解决问题的顺序随机化，这样不同的概念就会在长期记忆中被激活。但是要注意的是，随机化的顺序可以提高学习效果，但是需要更多的努力。第二个策略是在随机的时间间隔中进行短暂的休息，以增强记忆巩固。建议每2-5分钟休息10秒钟。 6. 互联网并没有使学习过时随着互联网的普及，编程知识的获取方式发生了很大的变化。有关语法或 API 的知识从参考书中浏览变成了只需要敲几下键盘。最近，像 ChatGPT、 Codex 和 GitHub Copilot 这样的人工智能工具甚至会为我们填写这些细节，而且大部分是准确的。这就提出了一个显而易见的问题: 如果知识可以在几秒钟内从互联网上获得，为什么还要学习编程的细节呢 ？ 我们通过在长期记忆中储存知识片段并在它们之间建立联系来学习。如果知识不存在于大脑中，大脑不能在它们之间建立任何联系，所以更高层次的理解和抽象是不可能的。如果每次需要一段代码来做一个数据库连接，就在网上搜索并复制，然后继续，你将不太可能学到很多关于数据库连接的知识。依赖互联网或人工智能的智慧在初学者和专家之间是不同的: 一个初学者从未学习过细节，因此缺乏记忆联系，而一个专家学习过更深层次的结构，但是寻找被遗忘的细节，这两者之间有着关键的区别。 在互联网上搜索记忆信息的效率较低，一项研究发现，如果信息是通过互联网找到的(与纸质书相比) ，记忆力就会下降，似乎搜索可能会剥夺大脑回忆信息强化效应的好处。还有前面的认知负荷问题。互联网搜索需要一种大脑上下文切换的形式; 它有限的注意力和工作记忆必须从手头的任务(编程)切换到一个新的认知任务(搜索互联网并选择一个结果或评估人工智能生成的结果)。如果所需的知识被记住，那么不仅访问速度更快(比如使用缓存和从硬盘获取) ，而且还避免了上下文切换的认知流失以及从搜索中过滤掉无关信息。因此，尽管信息可以在互联网上获得，但是记忆信息还是有很多原由的。 7. 解决问题并不是一个通用的技能解决问题是编程中的一个很大的部分。软件开发中一个常见的想法是将问题解决作为一种特定的技能，然后将其应用于开发的不同方面(设计、调试等)。因此，解决问题被错误地认为是一种通用的技能。然而，这并不是解决问题在大脑中的工作方式。 虽然人类确实拥有一些通用的问题解决技能，但它们远不如特定领域的问题解决技能(如能够调试程序)有效。虽然我们可以学习推理，但是不能学习如何解决一般的问题。相反，我们学习如何解决编程问题，或如何计划最好的流程，或如何创建一个设计模式。每一项技能都是独立的，不会影响其他技能。这种无法转移解决问题的技能说明了“大脑训练”对发展一般智力的开发可能是无效的。 这条规则的一个例外似乎是空间技能。空间技能使我们能够在头脑中想象物体，比如俄罗斯方块的形状，并在头脑中操纵这些物体，比如旋转俄罗斯方块的形状。训练这些通用技能可以改善其他学科的学习。这种现象是很不寻常，空间训练提高了一系列非语言技能的表现，可以提高软件开发人员的效率。即使有这个奇怪的例外，学习如何解决编程问题的最好方法仍然是练习解决编程问题，而不是学习下棋或其他。 这里还有一个招聘上的意义。筛选程序员候选人的一个流行想法是给出一些脑筋急转弯的谜题，比如如何称一架大型喷气式客机的重量。正如谷歌在2013年发现的那样，这是在浪费时间，脑筋急转弯世界中的问题解决与编程世界中的问题解决之间没有可靠的对应关系。如果想判断编程能力，就要直接评估编程代码。 8. 专业知识在某些情况下可能会出问题专业知识有利于学习和性能的许多方面，然而，成为专家也会导致问题。 程序员使用工具来提高效率，例如版本控制系统或 IDE。这些工具对初学者和专家有不同的影响。由于认知负荷的增加。初学者可能会被专业工具中的大量选项弄得不知所措，并且可能会从初学者友好的关于如何使用工具的提示中受益。然而，专家们发现同样的提示更让人分心，而不是有用。这就是所谓的专业知识反转效应: 帮助初学者的提示和指南可能会妨碍专家的工作，降低他们的工作效率。 程序员通常在整个职业生涯中学习多种编程语言。一旦掌握了多种语言，了解多种语言可能是有益的，但有时将知识从一种编程语言转移到另一种编程语言可能会导致错误的知识。例如，在学习OOP继承的时候，在 Java 中，只要签名匹配，一个方法就会重写父方法，然后将这些知识传递给 C + + ，在 C + + 中，重写父方法还需要将父方法声明为虚方法。这些差异在句法上相似，但语言之间在语义上的不同阻碍了知识的转移。 专家经常会帮助初学者，但是没有培训经验的专家往往没有意识到初学者的想法是不同的。因此，他们无法为具有不同思维模式的人量身定制做解释。这就是所谓的专家盲点问题: 一旦成为专家，就很难通过初学者的眼睛来看待事物。可以通过仔细听初学者解释他们目前的理解并相应地裁剪解释来克服这个问题。 然而，有时候，知识变得令专家们很难用语言来表达它。在这些情况下，初学者可能更好地从支持初学者的教学材料中学习，或者从同行那里学习。一个相对于新手更有知识的同行是一个非常有价值的资源，可以帮助初学者开发新知识，帮助专家重新发现直觉知识，弥合初学者和专家之间的差距。 9. 编程能力的预测因素尚不清楚像大多数活动一样，学习编程的成功建立在内在天赋和实践的结合之上。有些人认为这纯粹是天资问题，还有一些人认为，这几乎完全是实践问题，“10000小时”的观点认为，只有充分的实践才能获得专业知识。这两种极端的观点都是错误的。 对编程能力进行预测性测试的尝试通常都以失败告终。编程能力测试始于20世纪60年代，预测的准确性很差，这些测试已经不再使用。 经验的重要性与实践有关，这方面好坏参半。在Stack Overflow 上，程序员的声誉与他们的年龄有关联，年长者的声誉更高。然而，在职业生涯相对较早的程序员中，多年的经验和编程任务的成功之间只有很弱的联系，这表明能力可能比经验更有效，至少在程序员的职业生涯早期。 和大多数领域一样，有两个因素不能很好地预测早期编程的成功，这两个因素是一般智力水平和工作记忆能力。这些因素大致代表推理能力和学习者一次能处理多少信息。因此，他们预测的是学习速度而不是绝对能力。这两个因素的一个次级指标，空间推理是编程成功的一个较强的预测因子。空间推理也可以预测其他科学和数学领域的成功，所以这不是编程特有的。此外，由于各种原因，随着经验的增加，这些弱到中等程度的相关性基本上消失了。因此，聪明的人并不总是能成为优秀的程序员，优秀的程序员不一定具有很高的智商水平。 简而言之，很难预测谁将能够编程，程序员可能来自任何背景或人口统计，而且与任何其他因素的联系在面对经验时通常是转瞬即逝的。因此，在招聘新程序员时，没有确定编程能力的捷径。 10. 心态很重要在编程能力中有一个长期存在的说法：要么能编程，要么不能。这背后有许多相互矛盾的理论。其中一个更引人注目的理论是学习优势动量的概念，每个主题都依赖于以前的主题，所以一旦落后了，你将很难赶上。一个不那么引人注目的理论是“极客基因”概念，它没有什么经验证明。最近开始把编程能力的差异理解为先前经验的差异。看起来相似的学习者可能拥有截然不同的知识和技能，使他们在学习优势方面领先或落后，或者在短时间内使他们看起来“与生俱来”。 几乎每个人都可以学习一些物理，即使他们一开始并不擅长。然而，几乎没有人能够获得诺贝尔物理学奖，无论他们多么努力地练习。在这两个极端之间，我们经常试图找出自己能力的边界。 很难改变一个人的心态，使其更加以成长为导向。有两个常见错误观念，第一个是奖励努力而不是表现，因为成长心态更喜欢实践而不是才能。但是学习者并不愚蠢，他们可以看出自己什么时候没有进步，表扬徒劳的努力是没有帮助的。相反，只有当学习者使用有效的策略并在通往成功的道路上时，努力才会得到回报。第二个误解是当一个人带着成长心态处理一项任务时，他们会在整个任务过程中保持这种心态。在现实中，当我们面对挫折和经历失败时，我们不确定自己的能力界限在哪里。因此，我们必须练习克服挫折和失败，以保持成长的心态。 目的导向分为两类: 接近和回避。“接近”是想要做好，这会产生积极有效的学习行为: 努力学习，寻求帮助，尝试新的富有挑战性的课题。相比之下，“回避”是避免失败，这会导致消极和无效的行为: 无组织的学习，不寻求帮助，对表现的焦虑，以及回避挑战。需要注意的是，如果被指向“接近”而不是“回避”，人们可以在没有严重惩罚的情况下犯错误。 当学习一项新技能或训练某人掌握一项新技能时，以成长心态处理任务是有效的，也是一项需要发展的技能。不幸的是，不能简单地告诉人们要有成长的心态并从中获益。相反，需要通过寻求或提供关于学习过程和策略有效性的真实反馈来培养这种技能。感到沮丧是正常的，但这并不意味着你总是感到沮丧。如果你想放弃，休息一下，散散步，考虑一下你的策略，然后再试一次。 小结软件工程师必须不断学习，以跟上该领域的快速变化。学习任何东西，包括编程，都需要将内容放到记忆中。人的记忆非常复杂，虽然与计算机体系结构有一些相似之处，但是有一些关键的差异使得它的工作方式完全不同。 就招聘而言，如果你想知道应聘者的编程水平，看看他们以前的工作或者在真正的编程任务上测试他们，不要用脑筋急转弯来测试候选人。至少在年轻的开发人员中，多年的经验可能不是衡量能力的可靠指标。让求职者在提出解决方案之前，先自己在一个房间里解决面试问题，因为面试官在解决问题时观察或要求谈话会增加认知负荷和压力，从而影响表现。 就学习而言，阅读大量的代码可以帮助人们成为一个更有效率的程序员。专家并不总是最擅长培训初学者。学习需要时间，临时抱佛脚没有效果，但间隔重复有效。同样，花时间远离一个问题或许可以帮助解决这个问题。互联网搜索或AIGC工具可以提高工作效率，但并不意味着学习已经过时。使用例子在抽象概念和具体可学习的事实之间切换。寻求成功而不是避免失败)，并相信能力是可变的，这些都是学习进步的重要因素。 话外音学习的重要性毋庸置疑，软件编程能力的提升需要学习与实践，软件架构能力的提升也是如此。多学习一些软件系统的架构有助于更好地对架构设计进行决策。","date":"2025-04-26","categories":["杂谈"],"tags":["哲思"]},{"title":"XAUT2025全国大学生信息安全竞赛新生预选赛-个人WP","url":"/2025/01/21/XAUT2025全国大学生信息安全竞赛新生预选赛-WP/","content":"","date":"2025-01-21","categories":["CTF相关"],"tags":["比赛个人WP"]},{"title":"大学的近期Coding之旅及随笔(2024年)","url":"/2024/10/24/大学的近期coding之旅及随笔-2024年/","content":"值此1024程序员节，祝各位节日快乐哈正是秋天，古人云：自古逢秋悲寂寥，我言秋日胜春朝。今天也算是有感而发吧！纯属个人的感想，望各位大佬指正。 进入正题~~之前学编程，只是单纯的出于兴趣，喜爱那种刷完竞赛题后看到AC100的心满意足，也享受绞尽脑汁后解开竞赛题的豁然开朗。随着上了大学，系统学习了操作系统、计算机组成等底层逻辑，在CTF比赛中查看文件反汇编后的结构抑或是MISC的脑洞大开、PWN的二进制旅程，都让作为萌新的我大开眼界，也终于get到了“山外有山，人外有人”。 现在C语言基本学完，也初步了解STL，数据结构等，在CTF比赛中边刷边学学到的各个领域的零碎知识，感觉之前学的其实只是冰山一角，感觉就是通往计算机领域的🚄才刚刚出站，美得令人窒息的风景还远在路上，等着我们去探索。 在打CTF的过程中，我发现自己实在是太渺小了，感觉就是井底之蛙，要学的东西实在是太多了。于是呢，为了建立自己的知识库，也是稍稍装一下（bushi）所以就建立自己的blog，既方便了自己，也便于他人查看，同时呢，也可以作为自己一步一个脚印成长的见证。 回想以前高中的时候，我在家就自学计网、密码学，本来学得畅快淋漓，但是奈何还有在校学习，所以没有很好地平衡学习与自己的兴趣，导致学的很累。现在上大学了，成天和代码打交道，既要刷刷leetcode、debug，还要肝高数、线代，感觉真的非常地“充实”啊！特别是在打CTF的那段时间里，脑细胞直接给我干到野兽模式。 那时，打CTF时flag总是离我而去，让我思考究竟该不该走这条路。但是想到《牧羊少年奇幻之旅》中的“没有一颗心，会因为追求梦想而受伤。当你真心渴望某样东西时，整个宇宙都会来帮忙。”于是乎，我重振旗鼓，真正全身心投入到CTF的狂欢之中。当我享受到那种自由灵魂的探索、狂欢时，感觉真的很爽欸！当然，那次CTF也获得第二的名次，让作为新手的我也为之一振！ 感慨~~钱德勒曾说“说一声再见，就是死去一点点。”那我只能对之前脆弱、无知、渺小的我说再见了！心若不死，则道不生。一点点成长。共勉。💪","date":"2024-10-24","categories":["杂谈"],"tags":["随笔"]},{"title":"第一次blog的Hello World(留作纪念~~)","url":"/2024/10/13/hello-world/","content":"第一篇文章，来扯一下淡…这是我的第一篇文章，请大家多多支持我！ 初衷其实，在我读高中时，学习编程、翻看别的大佬的blog的时候，就已经萌生了自己写blog的想法。奈何…懂的都懂，要考高考，所以呢，计划搁置了很久。终于考完高考，我也能尽情遨游在编程、CS的海洋中了。 小小的实现现在是在读大一，看到有大二的CTF学长搭建了自己的blog，于是…手痒啊！就这样，degu8ger的blog诞生了！最初，觉得搭建blog要从零开始完全自己手搓一个出来，但是如今看来，技术飞速发展，都有现成的框架、demo了，只需引用一下即可。所以，事不宜迟，我选用了Hexo，大概断断续续地捣鼓了有三天吧，一个简陋的demo版出现了！！后续还得自己购置服务器(bushi)或者租一台，弄个域名…现在大一只看到经费在燃烧哇。其实呢，看到自己把别的佬的resources学到并记录在互联网这样一个大家庭中，也算是一种对自己努力学习的见证吧！ 感触之前遇到CS上的一些问题，在互联网上搜索，看到好的、精妙绝伦的就会点击收藏在收藏夹中。时间久了，收藏夹已经满了，而自己没有把他们分门别类的分好，便于自己以后查找。这也是我下定决心搭建blog的其中一个原因吧！特别是最近在疯狂肝CTF，在网上查找了a deluge of 信息，看到大佬的blog做得精彩绝伦、赏心悦目，自己已然心动。出于对技术的渴望也是对自己近一段时间以来获取信息的掌握度，搭建自己的blog也是对自己成长的见证。搭建blog，既是对自己在编程、学CS上的一点点见证，同时也可以锻炼自己的代码能力，包括后期维护啥的。将来工作时也可以呢…欸，不能明说。任何时候起步都不晚，重要的是起步了，就一切都好说。","date":"2024-10-13","categories":["杂谈"],"tags":["随笔"]},{"title":"404","url":"//404.html","content":"","date":"2025-09-26"},{"title":"Categories","url":"/categories/index.html","content":"","date":"2025-06-01"},{"title":"About ME","url":"/about/index.html","content":"(该博客为学习闲暇之余所建，记录一些自己学习时的点滴，也算是对自己成长道路的见证吧) 某喜欢摸鱼的非正经CTF萌新， 最近在看re、pwn，头疼ing(Assembly、WSL…) 大二在读，没事儿刷刷美剧(西部世界、黑镜…)、听听ImagineDragons、去湖边跑跑步、心血来潮时… 爱好健身、跑步(应该不冲突叭)、等等… 还在建设中，师傅们轻喷 :) SOCIALGithub: https://github.com/incldue email: h52463398@outlook.com …..","date":"2025-06-01"},{"title":"Tags","url":"/tags/index.html","content":"","date":"2025-06-01"},{"title":"Search","url":"/search/index.html","content":"","date":"2025-06-01"}]